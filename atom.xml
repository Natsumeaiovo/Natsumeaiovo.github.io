<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Serein&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/ff52826797d8c480a4184e29beabd20d</icon>
  
  <link href="https://serein.fun/atom.xml" rel="self"/>
  
  <link href="https://serein.fun/"/>
  <updated>2022-03-02T07:11:39.434Z</updated>
  <id>https://serein.fun/</id>
  
  <author>
    <name>Serein</name>
    <email>natsumeaiovo@outlook.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用信号量实现进程同步和互斥</title>
    <link href="https://serein.fun/2022/02/28/semaphore/"/>
    <id>https://serein.fun/2022/02/28/semaphore/</id>
    <published>2022-02-28T13:14:28.000Z</published>
    <updated>2022-03-02T07:11:39.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>进程互斥的四种软件实现方式：单标志法、双标志先检查、双标志后检查、Peterson 算法</p><p>进程互斥的三种硬件实现方式：中断屏蔽方法、TS/TSL 指令、Swap/XCHG 指令</p><p>这些进程互斥的实现方案存在如下问题：</p><ol><li><p>在双标志先检查法中，进入区的“检查”、“上锁” 操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题；</p></li><li><p>所有的解决方案都无法实现“让权等待”</p></li></ol><p>于是引入了一种卓有成效的实现进程互斥、同步的方法——<strong>信号量机制</strong>。信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语 <strong>wait(S)</strong> 和 <strong>signal(S)</strong> 访问，也可记作 <strong>P 操作</strong>（proberen）和 <strong>V 操作</strong> （verhogen）。</p><p><strong>原语</strong>是指完成某种功能且不被分割、不被中断执行的操作序列，通过可由硬件来实现。例如 Test-and-Set 和 Swap 指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。原语之所以不能被终端执行，是因为原语对变量的操作过程若被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。</p><h3 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h3><p>整型信号量被定义为一个用于表示资源数目的整型量 S ，wait 和 signal 操作可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// wait 和 signal 操作</span><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//“检查”和“上锁”一气呵成，避免了并发，异步导致的问题</span>    S <span class="token operator">=</span> S <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    S <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 进程P0</span><span class="token function">P0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//进入区，申请资源  </span>    visit resources<span class="token punctuation">;</span>    <span class="token comment">//临界区，访问资源</span>    <span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//退出区，释放资源</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在整型信号量机制中的 wait 操作，只要信号量 S ≤ 0，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。</p><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>记录型信号量机制是一种不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数目的整型变量 value 外，再增加一个进程链表 L ，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构。记录型信号量可描述为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">process</span> <span class="token operator">*</span>L<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> semaphore<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相应的 wait(S) 和 signal(S) 的操作如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//即 P 操作，相当于申请资源</span>    S<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        add <span class="token keyword">this</span> process to S<span class="token punctuation">.</span>L<span class="token punctuation">;</span>        <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//自我阻塞，放弃处理机</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Void <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//即 V 操作，相当于释放资源</span>    S<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        remove a process P from S<span class="token punctuation">.</span>L<span class="token punctuation">;</span>        <span class="token function">wakeup</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将 S.L 中的第一个等待进程唤醒</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用信号量实现同步"><a href="#利用信号量实现同步" class="headerlink" title="利用信号量实现同步"></a>利用信号量实现同步</h2><p>信号量机制能用于解决进程间的各种同步问题。设 S 为实现进程 P1，P2同步的公共信号量，初值为 0 。进程 P2 中的语句 y 要使用进程 P1 中语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。其实现进程同步的算法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphote S <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//初始化信号量</span><span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    x<span class="token punctuation">;</span>      <span class="token comment">//语句 x</span>    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//告诉 P2 语句 x 已完成，有资源</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//检查 x 是否完成，即申请资源，若没有则阻塞</span>    y<span class="token punctuation">;</span>      <span class="token comment">//检查无误，执行 y</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若 P2 先执行到 P(S) 时，S 为 0 ，执行 P 操作会把进程 P2 阻塞，并放入阻塞队列；当进程中的 x 执行完后，执行 V 操作，把 P2 从阻塞队列中放回就绪队列，当 P2 得到处理机时，就得以继续执行。</p><h2 id="利用信号量实现进程互斥"><a href="#利用信号量实现进程互斥" class="headerlink" title="利用信号量实现进程互斥"></a>利用信号量实现进程互斥</h2><p>信号量机制也能很方便地解决进程互斥问题。设 S 为实现进程 P1 ，P2互斥的信号量，由于每次只允许一个进程进入临界区，所以 S 的初值应为 1（即可用资源数为 1）。只需把临界区置于 P(S) 和 V(S) 之间，即可实现两个进程对临界资源的互斥访问。其算法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphote S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// mutex，初始化信号量</span><span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//准备开始访问临界资源，加锁</span>    进程 P1 的临界区<span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//访问结束，解锁。</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//准备开始访问临界资源，加锁</span>    进程 P2 的临界区<span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//访问结束，解锁。P、V 操作必须成对出现</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>互斥是不同进程对同一信号量进行 P , V 操作实现的，一个进程成功对信号量执行了 P 操作后进入临界区，并在退出临界区后，由该进程本身对该信号执行 V 操作，表示当前没有进程进入临界区，可以让其他进程进入。在互斥问题中，P , V 操作要紧夹使用互斥资源的哪个行为，中间不能有其他冗余代码。</p><h2 id="利用信号量实现前驱关系"><a href="#利用信号量实现前驱关系" class="headerlink" title="利用信号量实现前驱关系"></a>利用信号量实现前驱关系</h2><p>进程 P1 中有句代码 S1，P2 中有句代码 S2 ，P3中有句代码S3 …… P6 中有句代码 S6。这些代码要求按如下前驱图所示的顺序来执行：</p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/blog/post/image-20220301130129923.png" alt="image-20220301130129923" style="zoom: 67%;" /><p>整理思路：</p><ol><li><p>要为每一对前驱关系各设置一个同步信号量</p></li><li><p>在“前操作”之后对相应的同步信号量执行 V 操作</p></li><li><p>在“后操作”之前对相应的同步信号量执行 P 操作</p></li></ol><p>实现算法如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphore a <span class="token operator">=</span> b <span class="token operator">=</span> c <span class="token operator">=</span> d <span class="token operator">=</span> e <span class="token operator">=</span> f <span class="token operator">=</span> g <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    S1<span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    S2<span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token function">P3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    S3<span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token function">P4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    S4<span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token function">P5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    S5<span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token function">P6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">P</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">P</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">P</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>    S6<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>问题描述：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）生产者、消费者共享一个初始为空、大小为n的缓冲区。</p><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。<br>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。<br>缓冲区是临界资源，各进程必须互斥地访问。 </p><p>PV操作分析步骤：</p><ol><li><p>关系分析。找出问题中描述的各个进程，分析它们之间的同步、互斥关系。</p></li><li><p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p></li><li><p>设置信号量。并根据条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//互斥信号量，实现对缓冲区的互斥访问</span>semaphore empty <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">//同步信号量，表示空闲缓冲区的数量</span>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//同步信号量，表示产品的数量，也即“满”缓冲区的数量</span><span class="token function">producer</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//生产者进程</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    produce an item in nextp<span class="token punctuation">;</span>   <span class="token comment">//生产数据</span>    <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//获取空缓存区单元</span>    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//互斥夹紧，进入临界区</span>    add nextp to buffer<span class="token punctuation">;</span>        <span class="token comment">//将数据放入缓冲区</span>    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//离开临界区，释放互斥信号量</span>    <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//满缓冲区数 + 1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">consumer</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//消费者进程</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">P</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//获取满缓存区单元</span>    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//互斥夹紧，进入临界区</span>    remove an item from buffer<span class="token punctuation">;</span> <span class="token comment">//从缓冲区中取出数据</span>    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//离开缓冲区，释放互斥信号量</span>    <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">//空缓冲区数 + 1</span>    consume the item<span class="token punctuation">;</span>           <span class="token comment">//消费数据</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Question: 若生产者先执行 P(mutex) ，然后执行 P(empty) ，消费者执行 P(mutex) ，然后执行 P(full) ，是否可行？如果V 操作前后顺序互换呢？</p><p>Answer: 若此时缓冲区内已经放满产品，则 empty = 0，full = n。 则生产者进程执行 ① 使 mutex 变为 0 ，再执行 ② ，由于已没有空闲缓冲区，因此生产者被阻塞。 由于生产者阻塞，因此切换回消费者进程。消费者进程执行 ③ ，由于 mutex 为 0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。 这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。 同样的，若缓冲区中没有产品，即 full = 0，empty = n。按 ③④① 的顺序执行就会发生死锁。 因此，实现互斥的 P 操作一定要在实现同步的 P 操作之后。 </p><p>V 操作不会导致进程阻塞，因此两个 V 操作顺序可以交换。</p><h3 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h3><p>问题描述：桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用 PV 操作实现上述过程。</p><ol><li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p></li><li><p>整理思路。根据各进程的操作流程确定 P、V 操作的大致顺序。</p></li><li><p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1 ，同步信号量的初始值要看对应资源的初始值是多少）</p></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">//实现互斥访问盘子（缓冲区）</span>semaphore apple <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">//盘子中有几个苹果</span>semaphore orange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">//盘子中有几个橘子</span>semaphore plate <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">//盘子中还可以放多少个水果</span><span class="token function">dad</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        prepare an apple<span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>        put the apple on the plate<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token function">mom</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        prepare an orange<span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>        put the orange on the plate<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">daughter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>        take an apple from the plate<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>        eat the apple<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">son</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span>        take an orange from the plate<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span>        eat the orange<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Question: 这里并没有设置专门的互斥变量 mutex ，是否会出现多个进程同时访问盘子的现象？</p><p>Answer: 不会。本题中的缓冲区大小为1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是 1 。因此在任何时刻，最多只有一个进程的 P 操作不会被阻塞，并顺利地进入临界区。</p><p>如果 plate 容量为 2 的话，父亲 P(plate) ，可以访问盘子，母亲 P(plate) ，可以访问盘子，父亲在往盘子里放苹果，同时母亲也可以往盘子里放橘子。于是就出现了两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p><p>总结：在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现。互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。如果缓冲区大小大于 1 ，就必须专门设置一个互斥信号量 mutex 来保证互斥访问缓冲区。</p><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>问题描述：假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷 起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、 第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供 应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）。</p><ol><li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p></li><li><p>整理思路。根据各进程的操作流程确定 P、V 操作的大致顺序</p></li><li><p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为 1 ，同步信号量的初始值要看对应资源的初始值是多少）</p></li></ol><p>缓冲区大小为 1 ，同一时刻，四个同步信号量中至多有一个的值为 1 ,故不用专门设置一个互斥信号量 mutex。</p><table><thead><tr><th align="center">组合一</th><th>纸+胶水</th><th>第一个抽烟者取走东西</th></tr></thead><tbody><tr><td align="center">组合二</td><td>烟草+胶水</td><td>第二个抽烟者取走东西</td></tr><tr><td align="center">组合三</td><td>烟草+纸</td><td>第三个抽烟者取走东西</td></tr></tbody></table><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphore offer1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//桌上组合一的数量</span>semaphore offer2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//桌上组合二的数量</span>semaphore offer3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//桌上组合三的数量</span>semaphore finish <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//抽烟是否完成</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">//用于实现“三个抽烟者轮流抽烟”</span><span class="token function">provider</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             将组合一放桌上<span class="token punctuation">;</span>             <span class="token function">V</span><span class="token punctuation">(</span>offer1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            将组合二放桌上<span class="token punctuation">;</span>            <span class="token function">V</span><span class="token punctuation">(</span>offer2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            将组合三放桌上<span class="token punctuation">;</span>            <span class="token function">V</span><span class="token punctuation">(</span>offer3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">smoker1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//拥有烟草者</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>offer1<span class="token punctuation">)</span><span class="token punctuation">;</span>        从桌上拿走组合一<span class="token punctuation">;</span>卷烟<span class="token punctuation">;</span>抽掉<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">smoker2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//拥有纸者</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>offer2<span class="token punctuation">)</span><span class="token punctuation">;</span>        从桌上拿走组合二<span class="token punctuation">;</span>卷烟<span class="token punctuation">;</span>抽掉<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">smoker3</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//拥有胶水者</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>offer3<span class="token punctuation">)</span><span class="token punctuation">;</span>        从桌上拿走组合三<span class="token punctuation">;</span>卷烟<span class="token punctuation">;</span>抽掉<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。</p><p><strong>解法一：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphore rw<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">//用于实现对共享文件的互斥访问</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//记录当前有几个读进程在访问文件</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//用于保证对count变量的互斥访问</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//写之前“加锁”</span>        写文件<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//写完了“解锁” </span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//各读进程互斥访问count</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//由第一个读进程负责</span>            <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//读之前“加锁”</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token comment">//访问文件的读进程数+1</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        读文件<span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//各读进程互斥访问count</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token comment">//访问文件的读进程数-1</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//由最后一个读进程负责</span>            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//读完了“解锁”</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的。</p><p><strong>如何实现写进程优先？</strong></p><p><strong>解法二：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphore rw<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">//用于实现对共享文件的互斥访问</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//记录当前有几个读进程在访问文件</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//用于保证对count变量的互斥访问</span>semaphore w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">//用于实现“写优先”</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//写之前“加锁”</span>        写文件<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//写完了“解锁” </span>        <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//各读进程互斥访问count</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//由第一个读进程负责</span>            <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//读之前“加锁”</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token comment">//访问文件的读进程数+1</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        读文件<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//各读进程互斥访问count</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token comment">//访问文件的读进程数-1</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//由最后一个读进程负责</span>            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//读完了“解锁”</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能 同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。也称为“读写公平法”。</p><p>总结：读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。 其核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。最后，还要认真思考是如何解决“写进程饥饿”问题的。</p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>一张圆桌上坐着 5 名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><ol><li><p>关系分析。系统中有 5 个哲学家进程，5 位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p></li><li><p>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</p></li><li><p>信号量设置。定义互斥信号量数 chopstick[5]={1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按 0 ~ 4 编号，哲学家 i 左边的筷子编号为 i ，右边的筷子编号为 (i+1)%5。</p></li></ol><p>❌错解：每个哲学家吃饭前依次拿起左、右两支筷子</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphore chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//i号哲学家的进程</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//拿左</span>        <span class="token function">P</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//拿右</span>        吃饭<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//放左</span>        <span class="token function">V</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//放右</span>        思考<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果5个哲学家并发地拿起了自己左手边的筷子…每位哲学家循环等待右边的人放下筷子（阻塞），发生“死锁”。</p><p><strong>如何防止死锁的发生呢？</strong></p><ol><li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</li><li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li><li>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</li></ol><p>✅正解：下面仅给出一种方法实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">semaphore chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>、semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//互斥地取筷子</span><span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//i号哲学家的进程</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">P</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//拿左</span>        <span class="token function">P</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//拿右</span>        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        吃饭<span class="token punctuation">;</span>        <span class="token function">V</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//放左</span>        <span class="token function">V</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//放右</span>        思考<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：哲学家进餐问题的关键在于解决进程死锁。这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</p>]]></content>
    
    
    <summary type="html">信号量机制是一种功能较强的机制，可用来解决互斥与同步问题。</summary>
    
    
    
    <category term="OS" scheme="https://serein.fun/categories/OS/"/>
    
    
    <category term="学习" scheme="https://serein.fun/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>开学</title>
    <link href="https://serein.fun/2022/02/18/returncampus/"/>
    <id>https://serein.fun/2022/02/18/returncampus/</id>
    <published>2022-02-18T03:37:57.000Z</published>
    <updated>2022-02-21T01:58:59.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返校途中"><a href="#返校途中" class="headerlink" title="返校途中"></a>返校途中</h2><p>一大早七点起来，我这个在寒假里每天睡到十点的人，确实也该调整一下生物钟了。从家里坐高铁坐到学校需要坐11个小时，为啥不坐飞机是因为我家那边短距离内没有机场😂。。一到车上就开始犯困，睡了一觉后，又在车上看了一部番后终于到啦。</p><p>此时的我还在听着歌悠闲地在校园走着，却不知道我的蓝牙耳机仓已经掉在了车上(哭。到了学校已经是快十点了，还下着雨，路也没走多少就是很累，回去洗洗就睡了。</p><p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220218120338460.png"></p><p>于是第二天一早就去做核酸检测了，还是在下雨，为啥总是一返校就下雨呢？（半恼，希望疫情可以快点过去吧。</p><p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220218120720842.png"></p><h2 id="新的学期"><a href="#新的学期" class="headerlink" title="新的学期"></a>新的学期</h2><p>转眼就快要毕业了，不能做一条咸鱼了，因为要准备考研，所以博客的话更新应该不会太勤，还是会偶尔写写的。</p><p>那么，新的一年加油吧，愿一切都好👋</p>]]></content>
    
    
    <summary type="html">返校途中</summary>
    
    
    
    <category term="生活" scheme="https://serein.fun/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>oCam Screen Recorder</title>
    <link href="https://serein.fun/2022/02/15/oCam/"/>
    <id>https://serein.fun/2022/02/15/oCam/</id>
    <published>2022-02-15T12:10:06.000Z</published>
    <updated>2022-02-21T01:10:42.514Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="秘密不对哦！" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="21b05a16eda2640f1e47db935bf65c7932727e462a7e3646e436f6f38099492e">782dfba42359cdbed7d5819e141be56d6d33e500392155783f80c6c811a349eb5080f68603b33240c42553ffe2e6b7103d92fe8768fe1398f7153006e01e091e0ab8d8c94f03117c993d1700a7b8b3d2312ddb98b9e70bd4fa832d41df50abdb1983315d8a13fa4e5ed155b8f35d6c20b46a9bc04500c56adfa41901df61707995fc32177dd315669f51d2b83d20a36a05d63c060a688a6af8fd0cc8b1b1f74ae3f9e68952ed65e0494b8a78a6cc88c030c4f23f862ee82af8ccc3fb516279bb1d8e89d477c1174cb96c0365e1009f6a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Input password</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是个小秘密~</summary>
    
    
    
    <category term="工具" scheme="https://serein.fun/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://serein.fun/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CPU 数据通路的功能和基本结构</title>
    <link href="https://serein.fun/2022/02/13/cpu-datapath/"/>
    <id>https://serein.fun/2022/02/13/cpu-datapath/</id>
    <published>2022-02-13T14:11:20.000Z</published>
    <updated>2022-02-21T00:47:07.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据通路的功能"><a href="#数据通路的功能" class="headerlink" title="数据通路的功能"></a>数据通路的功能</h2><p>数据在功能部件之间传送的路径称为数据通路。路径上的部件称为数据通路部件，如 ALU 、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。</p><p>数据通路中专门进行数据运算的部件称为执行部件或功能部件。数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号，并正确控制指令的执行流程。数据通路的功能是实现 CPU 内部的<strong>运算器与寄存器</strong>及<strong>寄存器之间</strong>的数据交换。</p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220213223504323.png" style="zoom:70%;" /><h2 id="数据通路的基本结构"><a href="#数据通路的基本结构" class="headerlink" title="数据通路的基本结构"></a>数据通路的基本结构</h2><h3 id="CPU-内部单总线方式"><a href="#CPU-内部单总线方式" class="headerlink" title="CPU 内部单总线方式"></a>CPU 内部单总线方式</h3><p><strong>内部总线</strong>是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线。</p><p><strong>系统总线</strong>是指同一台计算机系统的各部件，如CPU、内存、通道和各类I/O接口间互相连接的总线。</p><h4 id="寄存器之间数据传送"><a href="#寄存器之间数据传送" class="headerlink" title="寄存器之间数据传送"></a>寄存器之间数据传送</h4><p>比如把PC内容送至MAR，实现传送操作的流程及控制信号为：</p><p>(PC)→Bus（PCout有效，PC内容送总线）</p><p>Bus→MAR（MARin有效，总线内容送MAR）</p><p>也可写为：(PC)→Bus→MAR</p><center><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220213231018210.png" style="zoom:70%;" /></center><hr><h4 id="主存与CPU之间的数据传送"><a href="#主存与CPU之间的数据传送" class="headerlink" title="主存与CPU之间的数据传送"></a>主存与CPU之间的数据传送</h4><p>比如CPU从主存读取指令，实现传送操作的流程及控制信号为：</p><p>(PC)→Bus→MAR（PCout和MARin有效，现行指令地址→MAR）</p><p>1→R（CU发读命令）（通过控制总线发出，图中未画出）</p><p>MEM(MAR)→MDR（MDRinE有效）</p><p>MDR→Bus→IR（MDRout和IRin有效，现行指令→IR）</p><center><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220213231751671.png" style="zoom:67%;" /></center><hr><h4 id="执行算术或逻辑运算"><a href="#执行算术或逻辑运算" class="headerlink" title="执行算术或逻辑运算"></a>执行算术或逻辑运算</h4><p>比如一条加·法指令，微操作序列及控制信号为：</p><p>Ad(IR)→Bus→MAR（AdIRout和MARin有效）（或MDRout和MARin有效）</p><p>1→R（CU发读命令）</p><p>MEM(MAR)→数据线→MDR（MDRinE有效）</p><p>MDR→Bus→Y（MDRout和Yin有效，操作数→Y）</p><p>(ACC)+(Y)→Z（ACCout和ALUin有效，CU向ALU发送加命令）</p><p>Z→ACC（Zout和ACCin有效，结果→ACC）</p><center><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220213234943548.png" style="zoom:67%;" /></center><hr><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>设有如图所示的单总线结构，分析指令 ADD (R0) , R1 的指令流程和控制信号。</p><center><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220214142128025.png" style="zoom:67%;" /></center><ol><li><p>分析指令功能和指令周期功能：((R0))+(R1)→(R0)</p><p>取指周期、间址周期、执行周期</p></li><li><p>写出各阶段的指令流程。</p><p>取指周期：公共操作。</p><table><thead><tr><th align="center">时序</th><th align="center">微操作</th><th align="center">有效控制信号</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">(PC)→MAR</td><td align="center">PCout，MARin</td></tr><tr><td align="center">2</td><td align="center">M(MAR)→MDR<br/>(PC)+1→PC</td><td align="center">MemR，MARout，<br/>MDRinE</td></tr><tr><td align="center">3</td><td align="center">(MDR)→IR</td><td align="center">MDRout，IRin</td></tr><tr><td align="center">4</td><td align="center">指令译码</td><td align="center">-</td></tr></tbody></table><p>间址周期：完成取数操作，被加数在主存中，加数已经放在寄存器R1中。</p><table><thead><tr><th align="center">时序</th><th align="center">微操作</th><th align="center">有效控制信号</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">(R0)→MAR</td><td align="center">R0out，MARin</td></tr><tr><td align="center">2</td><td align="center">M(MAR)→MDR</td><td align="center">MemR，MARout，<br/>MDRinE</td></tr><tr><td align="center">3</td><td align="center">(MDR)→Y</td><td align="center">MDRout，Yin</td></tr></tbody></table><p>执行周期：完成取数操作，被加数在主存中，加数已经放在寄存器R1中。</p><table><thead><tr><th align="center">时序</th><th align="center">微操作</th><th align="center">有效控制信号</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">(R1)+(Y)→Z</td><td align="center">R1out，ALUin，CU向<br/>ALU发ADD控制信号</td></tr><tr><td align="center">2</td><td align="center">(Z)→MDR</td><td align="center">Zout，MDRin</td></tr><tr><td align="center">3</td><td align="center">(MDR)→M(MAR)</td><td align="center">MemW，MDRoutE，<br/>MARout</td></tr></tbody></table></li></ol><h3 id="CPU内部三总线方式"><a href="#CPU内部三总线方式" class="headerlink" title="CPU内部三总线方式"></a>CPU内部三总线方式</h3><p>将所有寄存器的输入端和输出端都连接到多条公共线路上，相比之下单总线中一个时钟内只允许传一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。</p><h3 id="专用数据通路方式"><a href="#专用数据通路方式" class="headerlink" title="专用数据通路方式"></a>专用数据通路方式</h3><center><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220214171801459.png" style="zoom: 60%;" /></center><p>如上图，我们简要分析专用数据通路方式的取指周期。</p><p>(PC)→MAR（C0有效）</p><p>(MAR)→主存（C1有效）</p><p>1→R（控制单元向主存发送读命令）</p><p>M(MAR)→MDR（C2有效）</p><p>(MDR)→IR（C3有效）</p><p>(PC)+1→PC</p><p>Op(IR)→CU（C4有效）</p><hr><p><strong>举例：</strong>下图是一个简化了的CPU与主存连接结构示意图（图中省略了所有的多路选择器）。其中有一个累加寄存器（ACC）、一个状态数据寄存器（PSW）和其他4个寄存器：主存地址寄存器（MAR）、主存数据寄存器（MDR）、程序寄存器（PC）和指令寄存器（IR），各部件及其之间的连线表示数据通路，箭头表示信息传递方向。</p><center><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220214190638160.png" style="zoom: 67%;" /></center><ol><li><p>简述图中取指令的数据通路。</p><p>(PC) → MAR</p><p>M(MAR) → MDR</p><p>(MDR) → IR</p><p>OP(IR) → 微操作信号发生器</p></li><li><p>简述数据在运算器和主存之间进行存/取访问的数据通路。</p><p>存/取的数据放到 ACC 中，设数据地址已放入 MAR 。</p><p>取：</p><p>M(MAR) → MDR</p><p>(MDR) → ALU → ACC</p><p>存：</p><p>(ACC) → MDR</p><p>(MDR) → M(MAR)</p></li><li><p>简述完成指令 LDA X 的数据通路（X 为主存地址，LDA 的功能为(X)→ACC）。</p><p>X → MAR（X 即 Ad(IR)）</p><p>M(MAR) → MDR</p><p>(MDR) → ALU → ACC</p></li><li><p>简述完成指令 ADD Y 的数据通路（Y 为主存地址，ADD 的功能为(ACC)+(Y)→ACC）。</p><p>Y → MAR（Y 即 Ad(IR)）</p><p>M(MAR) → MDR</p><p>(MDR) → ALU, (ACC) → ALU</p><p>ALU → ACC</p></li><li><p>简述完成指令 STA Z 的数据通路（Z 为主存地址，STA的功能为(ACC)→Z）。</p><p>Z → MAR（Z 即 Ad(IR)）</p><p>(ACC) → MDR</p><p>(MDR) → M(MAR)</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><center><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220214194130871.png" style="zoom:80%;" /></center><p>涉及的主要操作类型：</p><ul><li><p>寄存器之间的数据传送；</p></li><li><p>主存与CPU之间的数据传送；</p></li><li><p>使用ALU进行算术逻辑运算。</p></li></ul>]]></content>
    
    
    <summary type="html">数据在功能部件之间传送的路径称为数据通路</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://serein.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="学习" scheme="https://serein.fun/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>2022新年快乐！</title>
    <link href="https://serein.fun/2022/02/01/newyear2022/"/>
    <id>https://serein.fun/2022/02/01/newyear2022/</id>
    <published>2022-01-31T16:09:57.000Z</published>
    <updated>2022-02-21T01:09:20.885Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201002705612.png"></p><p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201002738797.png"></p><p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201002759448.png"></p><p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201002831626.png"></p><p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201103327465.png"></p>]]></content>
    
    
    <summary type="html">ㅤ</summary>
    
    
    
    <category term="生活" scheme="https://serein.fun/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>初步理解红黑树</title>
    <link href="https://serein.fun/2022/01/15/RB-Tree/"/>
    <id>https://serein.fun/2022/01/15/RB-Tree/</id>
    <published>2022-01-15T12:12:53.000Z</published>
    <updated>2022-03-12T08:05:30.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为何需要红黑树？"><a href="#为何需要红黑树？" class="headerlink" title="为何需要红黑树？"></a>为何需要红黑树？</h2><p>平衡二叉树 AVL：插入/删除 很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行 LL/RR/LR/RL 调整。适用于以查为主、很少插入/删除的场景。</p><p>红黑树 RBT：插入/删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一般都可以在常数级时间内完成。适用于频繁插入、删除的场景，实用性更强。</p><h2 id="红黑树的定义与性质"><a href="#红黑树的定义与性质" class="headerlink" title="红黑树的定义与性质"></a>红黑树的定义与性质</h2><p>红黑树结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">RBnode</span><span class="token punctuation">&#123;</span>       <span class="token comment">//红黑树的结点定义</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>         <span class="token comment">//关键字的值</span>    RBnode<span class="token operator">*</span> parent<span class="token punctuation">;</span>  <span class="token comment">//父结点指针</span>    RBnode<span class="token operator">*</span> lchild<span class="token punctuation">;</span>  <span class="token comment">//左孩子指针</span>    RBnode<span class="token operator">*</span> rchild<span class="token punctuation">;</span>  <span class="token comment">//右孩子指针</span>    <span class="token keyword">int</span> color<span class="token punctuation">;</span>       <span class="token comment">//结点颜色，如：可用 0/1 表示 黑/红，也可使用枚举型enum表示颜色</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>红黑树是二叉排序树，满足左子树结点值 ≤ 根结点值 ≤ 右子树结点值。</p></li><li><p>与普通BST相比，有什么性质？</p><p>①每个结点或是红色，或是黑色的</p><p>②根节点是黑色的</p><p>③叶结点（外部结点、NULL结点、失败结点）均是黑色的</p><p>④不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</p><p>⑤对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</p><p>实例：一颗红黑树</p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220115203316375.png" style="zoom:40%;" /></li></ol><div class="note info flat"><p>结点的黑高 bh ：从某结点出发（不含该结点）到达任一空叶结点（含叶结点）的路径上黑结点总数。</p></div><p><strong>思考：</strong>根节点黑高为 h 的红黑树，内部结点数（关键字）至少有多少个？</p><p>Answer：内部结点数最少的情况——总共h层黑结点的满树形态，即：</p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116150104977.png" style="zoom: 80%;" /><p>结论：若根节点黑高为h，内部结点数（关键字）最少有 2<sup>h</sup>-1 个</p><p>进而有如下结论：</p><ul><li>结论1：从根节点到叶结点的最长路径不大于最短路径的2倍</li><li>结论2：有n个内部节点的红黑树高度 h ≤ 2$log_2 (n+1)$</li></ul><p>→ 红黑树查找操作时间复杂度 = $O(log_2 (n))$</p><p>性质1很容易证明，这里写下结论2的证明：</p><p><strong>证明：</strong>由结论1可知，从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为h/2，于是有n ≥ 2<sup>h/2</sup> - 1，即可求得结论。</p><p>可见，红黑树的“适度平衡”，由AVL树的“高度平衡”，降低到“任一结点左右子树的高度，相差不超过2倍”，也降低了动态操作，也降低了动态操作时调整的频率。对于一颗动态查找树，如果插入和删除操作比较少，查找操作比较多，采用AVL树比较合适，否则采用红黑树更合适。但由于维护这种高度平衡所付出的代价比获得的效益大得多，红黑树的实际应用更广泛，C++中的 map 和 set （Java 中的 TreeMap 和 TreeSet）就是用红黑树实现的。</p><h2 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>先查找，确定插入位置（原理同二叉排序树），插入新结点</p><ul><li><p>新结点是<strong>根</strong>——染为黑色</p></li><li><p>新结点<strong>非根</strong>——染为红色</p><ul><li><p>若插入新结点后依然满足红黑树定义，则插入结束</p></li><li><p>若插入新结点后不满足红黑树定义，需要调整，使其重新满足红黑树定义</p><ul><li>黑叔：旋转+染色<ul><li>LL型：右单旋，父换爷+染色</li><li>RR型：左单旋，父换爷+染色</li><li>LR型：左、右双旋，儿换爷+染色</li><li>RL型：右、左双旋，儿换爷+染色</li></ul></li><li>红叔：染色+变新 <ul><li>叔父爷染色，爷变为新结点</li></ul></li></ul></li></ul></li></ul><p><strong>例：</strong>从一棵空的红黑树开始，插入：20, 10, 5, 30, 40, 57, 3, 2, 4, 35, 25, 18, 22, 23, 24, 19, 18 </p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116000500362.png" style="zoom: 45%;" /><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116001531379.png" style="zoom:45%;" /><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116002640320.png" style="zoom:45%;" /><p>…</p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116002829660.png" style="zoom:80%;" /><p>一直重复上述操作，最终得到：</p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116002935419.png" style="zoom:45%;" /><h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><h3 id="1-删除红结点"><a href="#1-删除红结点" class="headerlink" title="1. 删除红结点"></a>1. 删除红结点</h3><p>对于删除红结点，其不会破坏红黑树原有的性质。<strong>第一</strong>，根结点到任意叶结点的黑结点数量不变，不会破坏红黑树的黑高；<strong>其次</strong>，删除红结点，不会有相邻的红结点出现，因为红结点的子结点总是黑色。删除红结点过程中，红结点可以分为：</p><ul><li>没有子结点</li><li>一个子结点</li><li>两个子结点</li></ul><p>此时，直接应用AVL树中删除结点的方法，对其进行删除，过程不再赘述。问题只剩下删除黑结点。</p><h3 id="2-删除黑结点"><a href="#2-删除黑结点" class="headerlink" title="2. 删除黑结点"></a>2. 删除黑结点</h3><p>删除黑结点的过程繁琐得多，主要分为以下情况：</p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116225206937.png" style="zoom:45%;" /><p>问题：“我”的一个黑色子结点被删除了，经调整后<strong>我和我的子树“1”构成的树已满足红黑树的性质，但是“父P”的左子树的黑高 -1</strong> ，如何修复整颗红黑树的性质？</p><p>对于如下不同情形的方案：</p><h4 id="哥黑，双侄黑，父黑"><a href="#哥黑，双侄黑，父黑" class="headerlink" title="哥黑，双侄黑，父黑"></a>哥黑，双侄黑，父黑</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116232723116.png" style="zoom:50%;" /><p><strong>方案：</strong>将哥S染红，问题解决。</p><h4 id="哥黑，双侄黑，父红"><a href="#哥黑，双侄黑，父红" class="headerlink" title="哥黑，双侄黑，父红"></a>哥黑，双侄黑，父红</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116225805164.png" style="zoom:50%;" /><p><strong>方案：</strong>直接将父P和哥S换色，问题解决。</p><h4 id="哥黑，顺侄红（逆侄色任意，父色任意）"><a href="#哥黑，顺侄红（逆侄色任意，父色任意）" class="headerlink" title="哥黑，顺侄红（逆侄色任意，父色任意）"></a>哥黑，顺侄红（逆侄色任意，父色任意）</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116231511669.png" style="zoom: 50%;" /><p><strong>方案：</strong>①首先对父P进行左旋；②将父P与哥S的颜色交换；③将顺侄染为黑色，问题解决。</p><h4 id="哥黑，顺侄黑，逆侄红（父色任意）"><a href="#哥黑，顺侄黑，逆侄红（父色任意）" class="headerlink" title="哥黑，顺侄黑，逆侄红（父色任意）"></a>哥黑，顺侄黑，逆侄红（父色任意）</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116234653862.png" style="zoom:50%;" /><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116233420377.png" style="zoom:50%;" /><p><strong>方案：</strong>①首先对哥S进行右旋，发现逆侄左子树“2”与右子树黑高不同；②将逆侄与哥S颜色互换，得到情形 4.2.3 ，问题递归。</p><h4 id="哥红"><a href="#哥红" class="headerlink" title="哥红"></a>哥红</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116235630256.png" style="zoom:50%;" /><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116235738368.png" style="zoom:50%;" /><p><strong>方案：</strong>①对父P进行左旋，发现哥S左右子树黑高不一致；②将父P和哥S颜色互换。得到情形 4.2.2 ，问题递归。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ] <a href="https://www.bilibili.com/video/BV1FS4y1976h/">https://www.bilibili.com/video/BV1FS4y1976h/</a></p><p>[ 2 ] <a href="https://www.bilibili.com/video/BV1uZ4y1P7rr/">https://www.bilibili.com/video/BV1uZ4y1P7rr/</a></p>]]></content>
    
    
    <summary type="html">“为何需要红黑树？”</summary>
    
    
    
    <category term="数据结构" scheme="https://serein.fun/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://serein.fun/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="二叉树" scheme="https://serein.fun/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>找到二叉树给定两结点的共同祖先</title>
    <link href="https://serein.fun/2021/12/26/common-ancestor-of-the-binary-tree/"/>
    <id>https://serein.fun/2021/12/26/common-ancestor-of-the-binary-tree/</id>
    <published>2021-12-25T17:28:11.000Z</published>
    <updated>2022-02-21T01:09:29.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><h3 id="如何得到一个给定结点的所有祖先？"><a href="#如何得到一个给定结点的所有祖先？" class="headerlink" title="如何得到一个给定结点的所有祖先？"></a>如何得到一个给定结点的所有祖先？</h3><span id="more"></span>我们很容易想到后序遍历，利用栈实现后序遍历时，遍历到某结点时，栈中所有元素即该结点祖先。<p>那么找出给定结点的所有祖先的算法如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//todo  输出x的所有祖先</span><span class="token keyword">void</span> <span class="token function">Anc_Print</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span> TElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BiTree p <span class="token operator">=</span> T<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//r先用来标记右子树是否被访问过</span>    SqStack S<span class="token punctuation">;</span> <span class="token function">InitSqStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">||</span> S<span class="token punctuation">.</span>top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">//进行后序遍历</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token comment">//一直入栈直到树的左下</span>        <span class="token punctuation">&#123;</span>            <span class="token function">SqPush</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>    <span class="token comment">//  转为右子树</span>        <span class="token punctuation">&#123;</span>            <span class="token function">SqGetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rchild <span class="token operator">!=</span> r<span class="token punctuation">)</span>    <span class="token comment">// 右子树存在且没被访问过</span>                p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>    <span class="token comment">//转向</span>            <span class="token keyword">else</span>    <span class="token comment">//  右子树不存在或被访问过了</span>            <span class="token punctuation">&#123;</span>                <span class="token function">SqPop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token comment">//找到值为x的结点，退出循环</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>                p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">//输出所有祖先</span>    <span class="token punctuation">&#123;</span>        <span class="token function">SqPop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c  "</span><span class="token punctuation">,</span>p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何找到两结点共同点祖先？"><a href="#如何找到两结点共同点祖先？" class="headerlink" title="如何找到两结点共同点祖先？"></a>如何找到两结点共同点祖先？</h3><p>由上面的过程，我们不难想到，后序遍历到某结点时，栈S中所有元素即该结点祖先。遍历到p或q时，将栈S中元素复制到一辅助栈S1里，再继续遍历到另一所求结点，那么从栈S栈顶开始逐个到辅助栈S1中去匹配，第一个匹配的结点即最近祖先。</p><h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><ol><li><p>首先我们希望输入想要找的结点的值，就能通过此值定向到该结点（树中所有结点data域均不同），从而去寻找共同祖先，那么首先我们需要指向data域等于我们input值的指针，可以通过如下代码实现：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//todo 找到指向x的指针</span>BiTree <span class="token function">Find_x</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span> TElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">-></span>data <span class="token operator">==</span> x<span class="token punctuation">)</span>        <span class="token keyword">return</span> T<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Find_x</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">Find_x</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span>  <span class="token function">Find_x</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过上述思想，将共同祖先保存到r：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Ancestor</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span> BiTree p<span class="token punctuation">,</span> BiTree q<span class="token punctuation">,</span> BiTree <span class="token operator">&amp;</span>r<span class="token punctuation">)</span>  <span class="token comment">//最后将最近共同祖先保存到 r</span><span class="token punctuation">&#123;</span>    BiTree temp <span class="token operator">=</span> T<span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//? temp为工作指针;先找到p,则x指向q,先找到q,则x指向p</span>    r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//? r先用来标记右子树是否被访问过</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//?  tag记录是否找到了p或q(此时栈S1中已复制完成)</span>    SqStack S<span class="token punctuation">;</span> <span class="token function">InitSqStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    SqStack S1<span class="token punctuation">;</span> <span class="token function">InitSqStack</span><span class="token punctuation">(</span>S1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">||</span> S<span class="token punctuation">.</span>top <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>    <span class="token comment">//? 一直入栈直到树的左下</span>        <span class="token punctuation">&#123;</span>            <span class="token function">SqPush</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            temp <span class="token operator">=</span> temp<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>    <span class="token comment">//?  转为右子树</span>        <span class="token punctuation">&#123;</span>            <span class="token function">SqGetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-></span>rchild <span class="token operator">&amp;&amp;</span> temp<span class="token operator">-></span>rchild <span class="token operator">!=</span> r<span class="token punctuation">)</span> <span class="token comment">//? 右子树存在且没被访问过</span>                temp <span class="token operator">=</span> temp<span class="token operator">-></span>rchild<span class="token punctuation">;</span>    <span class="token comment">//转向</span>            <span class="token keyword">else</span>    <span class="token comment">//?  右子树不存在或被访问过了</span>            <span class="token punctuation">&#123;</span>                <span class="token function">SqPop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//* 将栈顶结点出栈，让 temp指向它</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tag <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>temp <span class="token operator">==</span> p <span class="token operator">||</span> temp <span class="token operator">==</span> q<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">//*  tag = 1时，说明已找到p或者q,所以此if下语句全程只会执行一次</span>                <span class="token punctuation">&#123;</span>                    x <span class="token operator">=</span> temp<span class="token operator">==</span>p <span class="token operator">?</span> q <span class="token operator">:</span> p<span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> S<span class="token punctuation">.</span>top<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                        S1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    S1<span class="token punctuation">.</span>top <span class="token operator">=</span> S<span class="token punctuation">.</span>top<span class="token punctuation">;</span>                    tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> x<span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                r <span class="token operator">=</span> temp<span class="token punctuation">;</span>                temp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> i0 <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">//i0存放S1的栈顶</span>    j <span class="token operator">=</span> S<span class="token punctuation">.</span>top<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">//栈S从栈顶开始，从辅助栈S1中逐个寻找相同元素</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> S<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> S1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            i <span class="token operator">=</span> i0<span class="token punctuation">;</span>  <span class="token comment">//i重新指向栈顶</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">//继续从栈S下一个元素开始逐个与S1匹配</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>  <span class="token comment">//i>=0说明匹配成功，退出循环</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> S1<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>  <span class="token comment">//如果i&lt;0，则寻找失败，无共同祖先</span>        r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>返回指向r的指针（考虑到上面算法会出错的情况并完善）：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">BiTree <span class="token function">ComAnc_Node</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span> TElemType p<span class="token punctuation">,</span> TElemType q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BiTree r<span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>    n1 <span class="token operator">=</span> <span class="token function">Find_x</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    n2 <span class="token operator">=</span> <span class="token function">Find_x</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>n1 <span class="token operator">||</span> <span class="token operator">!</span>n2<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span>T<span class="token operator">-></span>data <span class="token operator">||</span> q<span class="token operator">==</span>T<span class="token operator">-></span>data<span class="token punctuation">)</span>        <span class="token keyword">return</span> T<span class="token punctuation">;</span>    <span class="token function">Ancestor</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>试运行：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> i<span class="token punctuation">;</span>    BiTree T<span class="token punctuation">,</span>Tnew<span class="token punctuation">,</span>com_anc<span class="token punctuation">;</span>    TElemType e1<span class="token punctuation">;</span>    <span class="token function">InitBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化二叉树后,树空否？\n%d(1:是 0:否) 树的深度=%d\n"</span><span class="token punctuation">,</span> <span class="token function">BiTreeEmpty</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">BiTreeDepth</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">StrAssign</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"ABDH#K###E##CFI###G#J##"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//按前序输入</span>    <span class="token function">CreateBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"构造二叉树后,树空否？\n%d(1:是 0:否) 树的深度=%d\n"</span><span class="token punctuation">,</span> <span class="token function">BiTreeEmpty</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">BiTreeDepth</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    e1 <span class="token operator">=</span> <span class="token function">Root</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"二叉树的根为: %c\n"</span><span class="token punctuation">,</span> e1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"树的高度:%d\n"</span><span class="token punctuation">,</span> <span class="token function">BtDepth_2</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n前序递归遍历二叉树T:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n中序递归遍历二叉树T:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n后序递归遍历二叉树T:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PostOrderTraverse</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n    层次遍历二叉树T:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">LevelOrderTraverse</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    com_anc <span class="token operator">=</span> <span class="token function">ComAnc_Node</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token string">'K'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>com_anc<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"最近祖先为：%c\n"</span><span class="token punctuation">,</span> com_anc<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入不合法或无共同祖先\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 运行结果：</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">前序递归遍历二叉树T<span class="token operator">:</span> ABDHKECFIGJ中序递归遍历二叉树T<span class="token operator">:</span> HKDBEAIFCGJ后续递归遍历二叉树T<span class="token operator">:</span> KHDEBIFJGCA最近祖先为<span class="token operator">:</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
    <summary type="html">基于后序遍历</summary>
    
    
    
    <category term="数据结构" scheme="https://serein.fun/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://serein.fun/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="二叉树" scheme="https://serein.fun/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数制与编码</title>
    <link href="https://serein.fun/2021/12/03/Number-system-coding/"/>
    <id>https://serein.fun/2021/12/03/Number-system-coding/</id>
    <published>2021-12-03T13:55:46.000Z</published>
    <updated>2022-02-21T01:09:16.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><p>二进制 → 八进制：  3位一组</p><p>二进制 → 十六进制  4位一组</p><p>十进制 → 任意进制</p><p>整数部分：除基取余法</p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204011910835.png" style="zoom: 80%;" /><p>小数部分：乘基取整法</p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204013540140.png" style="zoom: 67%;" /><p><strong>真值：符合人类习惯的数字，如+15、-8等</strong></p><p><strong>机器数：数字实际存到机器里的形式，正负号需要被“数字化”。常用的有原码、补码和反码表示法。</strong></p><hr><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><p>二进制编码的十进制数（Binary-Coded Decimal, BCD）通常采用 4 位二进制数来表示一位十进制数中的 0~9 这10个编码。这种编码方法使二进制数和十进制数之间的转换得意快速进行。但4位二进制数可以组合出 2<sup>4</sup> 种代码，因此必有 6 种状态为冗余。列举几种常用BCD码：</p><h3 id="8421码（最常用）"><a href="#8421码（最常用）" class="headerlink" title="8421码（最常用）"></a>8421码（最常用）</h3><p>是一种有权码，权值从高到低依次为8,4,2,1，下图为其映射关系</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">0001</td><td align="center">0010</td><td align="center">0011</td><td align="center">0100</td><td align="center">0101</td><td align="center">0110</td><td align="center">0111</td><td align="center">1000</td><td align="center">1001</td></tr></tbody></table><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204105204096.png" style="zoom: 80%;" /><p>注：若相加结果在合法范围内，则无需修正。</p><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><p>余3码 = 8421码 + (0011)</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">0011</td><td align="center">0100</td><td align="center">0101</td><td align="center">0110</td><td align="center">0111</td><td align="center">1000</td><td align="center">1001</td><td align="center">1010</td><td align="center">1011</td><td align="center">1100</td></tr></tbody></table><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><p>2421码改变了权值定义，四位二进制码对应权值从高到低依次为2,4,2,1，并且规定：表示0-4时，最高位为0；表示5-9时最高位为1。</p><p>映射关系如下：</p><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">0001</td><td align="center">0010</td><td align="center">0011</td><td align="center">0100</td><td align="center">1011</td><td align="center">1100</td><td align="center">1101</td><td align="center">1110</td><td align="center">1111</td></tr></tbody></table><hr><h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><h3 id="字符编码与ASCII码"><a href="#字符编码与ASCII码" class="headerlink" title="字符编码与ASCII码"></a>字符编码与ASCII码</h3><p>数字 + 字母 + 符号 = 共128个字符 -&gt; 7位二进制编码（2<sup>7</sup> = 128）-&gt; ASCII码</p><p>每个字节的最高位保持为 0，可用于传输时的奇偶校验位。下图为ASCII字符代码表：</p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204112630157.png" style="zoom: 80%;" /><p>其中：</p><p>可印刷字符：32～126，其余为控制、通信字符</p><p>数字：48(0011 0000)～57(0011 1001)</p><p>大写字母：65(0100 0001)～90(0101 1010)</p><p>小写字母：97(0110 0001)～122(0111 1010)</p><h3 id="汉字的表示与编码"><a href="#汉字的表示与编码" class="headerlink" title="汉字的表示与编码"></a>汉字的表示与编码</h3><ol><li><p><strong>汉字编码：</strong>包括汉字的输入编码、汉字内码、汉字字形码三种，是在计算机中用于输入、内部处理和输出三种用途的编码。</p></li><li><p><strong>区位码：</strong>区位要分开看，是区码和位码的组合。用两个字节表示一个汉字，每字节用七位码，将汉字和图形符号排列在一个 94 行 94 列的二维代码表中。区位码是 4 位十进制数，前 2 位是区码，后 2 位是位码，所以称为区位码。</p><table><thead><tr><th align="center">区码\位码</th><th align="center">0</th><th align="center">1</th><th align="center">…</th><th align="center">94</th></tr></thead><tbody><tr><td align="center">0</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">…</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">94</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p><strong>国际码：</strong>将十进制的区位码转换为十六进制数后，再在每字节上加上 20H 。国际码两字节的最高位都是 0 ，ASCII码的最高位也是 0 。</p><div class="note success flat"><p>（为什么要加入2020H呢？）ASCII码表前32（20H）位 0 - 31 都是用于通信和控制的字符，加上2020H后，可以防止信息交换时与“控制/通信字符”冲突。</p></div></li><li><p><strong>汉字内码：</strong>为了方便计算机区分中文字符和英文字符，将国际码两字节的最高位都改为”1”，这就是汉字内码。要保证最高位为“1”，所以要加上8080H。（注意是在国际码基础上 + 8080H）</p></li></ol><p>区位码和国际码都是输入码，它们和汉字内码的关系（十六进制）如下：</p><p><strong>国际码 = （区位码）<sub>16</sub> + 2020H</strong></p><p><strong>汉字内码 = （国际码）<sub>16</sub> + 8080H</strong></p><hr><h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><p><strong>码字：</strong>由若干位代码组成的一个字叫码字。</p><p><strong>校验码：</strong>指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。</p><p><strong>码距：</strong>将两个码字逐位进行对比，具有<strong>不同的位的个数</strong>称为两个码字间的<strong>距离</strong>。一种编码方案可能有若干个合法码字，各合法码字间的<strong>最小距离</strong>称为“码距”。（如 1100 和 1101 之间的码距为 1，因为只有最低位翻转了。而1001和0010之间的码距则为3，因为只有1位没有变化）</p><p>当d=1时，无检错能力；当d=2时，有检错能力；当d≥3时，若设计合理，可能具有检错、纠错能力。</p><p><strong>码距越大，检错、纠错的能力就越强，而且检错能力总是大于等于纠错能力。</strong></p><p>对于检错、纠错能力与码距的具体关系如下：（e,t 为整数）<br>码距 $\geq e + 1; $(可检测 e 个错误)<br>码距 $\geq 2t + 1; $(可纠正 t 个错误)<br>码距 $\geq e + t + 1 (e \geq t); $(可检测 e 个错误，同时纠正 t 个错误) (想要增加检测数量，则需要减少纠正数量)</p><p>码距越大，抗干扰能力越强，纠错能力越强，但数据冗余越大，编码效率低，编码电路也相对复杂。</p><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ul><li>奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数。</li><li>偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数。</li></ul><center><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204143620554.png" style="zoom:80%;" /></center><p>eg.给出两个编码1001101和1010111的奇校验码和偶校验码。</p><p>解：设最高位为校验位，余7位是信息位，则对应的奇偶校验码为：</p><p>奇校验： <u>1</u>1001101 ····· <u>0</u>1010111 （异或结果为0说明出错）</p><p>偶校验： <u>0</u>1001101 ····· <u>1</u>1010111 （异或结果为1说明出错）</p><p>上面我们可以数出“1”的个数来得到对应的奇偶校验码，那么<strong>机器</strong>是如何得到奇偶校验检错码的呢？？（采用异或操作）</p><p>对于机器，它算出的(这里注意<strong>指误码</strong>并不是<strong>校验位</strong>，注意区分S和P的含义)</p><p>奇校验<strong>指误码</strong>：<br>$$<br>S_奇 = \overline{P \oplus X_1\oplus X_2\oplus X_3\oplus …\oplus X_n}<br>$$<br>偶校验<strong>指误码</strong>：<br>$$<br>S_偶 = P \oplus X_1\oplus X_2\oplus X_3\oplus …\oplus X_n<br>$$</p><p>$X_1,X_2,…,X_n$ 表示被校验的数据，P为校验位，当$S_{奇/偶} = 0$表示数据正常(并不可证明数据无错误!)，否则表示出错</p><p><strong>Question: 奇/偶校验码的码距为？</strong></p><div class="note info flat"><p>Answer：<strong>一定为2。</strong>一般地，比如8421码：0000，0001，…，1111，奇偶校验就是一个码组（如8421）内的任意2个有效编码间的不同位数（因为是任意的2个，所以在8421中取0000和0001只有1位不同），码距为1。加上奇偶校验后，使1的个数变为奇数或偶数（如0001变00010为奇，变00011为偶），此码组都这样编码（奇校验：00001，00010，…，11111）码距最小为2。</p></div><p><strong>缺点：</strong>具有局限性，只能发现数据代码出错位的个数为<strong>奇数情况下的错误</strong>，比如2个或4个或2n个位都出错了，此时校验失效。而且不能确定是哪一位出错。只有1个校验位，故只能携带 true or false 2种状态信息，<strong>只能检测奇数个错误，不能纠正错误</strong>。</p><p>到这里你可能会有个疑问，为什么奇偶校验码的码距为2，却可以检测出1、3、…、2n + 1 个错误呢？公式不是说好了应该只能检测出1个错误吗？↓</p><div class="note info flat"><p>码距 $\geq e + 1; $(可检测 e 个错误)</p></div><p>其实并不矛盾，我们来看看码距的定义：<strong>一种编码方案可能有若干个合法码字，各合法码字间的最小距离称为“码距”。</strong>我们举例一种编码方案例如：0001,0010,0100,1100 显然这个编码方案的码距为 2 ，那么可以知道，这组码字如果出现一个错误，都可以检测出来，例如第一个码字出现错误00<u>1</u>1，那么00<u>1</u>1就不在此编码方案中，检测到错误。如果出现3个错误，例如第一个码字变为了<u>11</u>0<u>0</u>，那么它即与最后一个码字是相同的，不能检测出错误。</p><p>为什么奇偶校验码码距也为2，可以检测出奇数个错误呢？上述的编码方案，它并不是奇偶校验码，码字“1100”有偶数个“1”。区别就在这里！假如编码方案变为：0001,0010,0100,1000，这样每个码字都是奇校验码，当发生了3（or 2n+1）个错误，那么那个码字一定会变成偶数个“1”，所以说上述公式是针对一般码字而言的。</p><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>海明校验：</p><ul><li>是一种多重分组奇偶校验</li><li>将代码组织为若干分组，每组进行奇偶校验</li><li>能够检验是否出错，并能定位出错位</li></ul><h4 id="海明码设计思路"><a href="#海明码设计思路" class="headerlink" title="海明码设计思路"></a>海明码设计思路</h4><p>待编码信息n位，分成k组，每组1各校验位</p><p>校验码位数：k位</p><p>海明编码总长：N = n + k位</p><p>海明编码时：各组单独进行奇偶校验编码，以确定各组的校验位。</p><p>代码检验时：每组能产生1个指误码 <strong>S</strong> </p><ul><li>r位指误码 比如：S<sub>3</sub>S<sub>2</sub>S<sub>1</sub>S<sub>0</sub></li><li>2<sup>r</sup>种可能的指误代码，如0000、0001、0010、…</li></ul><p>指误码 S 全为 0  &hArr; 海明编码无错，其余(2<sup>k</sup>-1)种情况均表示编码出错</p><p>而各参数应满足：$N = n + k \leq 2^k - 1$</p><p>例如k = 4，则需要r&gt;=3满足上述定理，可组成7位海明码，n和k的一些对应取值关系：</p><table><thead><tr><th align="left">n</th><th align="left">1</th><th>2-4</th><th>5-11</th><th>12-26</th><th>27-57</th><th>58-120</th></tr></thead><tbody><tr><td align="left">k</td><td align="left">2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><h4 id="海明码求解步骤"><a href="#海明码求解步骤" class="headerlink" title="海明码求解步骤"></a>海明码求解步骤</h4><p>举例：信息位为1010</p><ol><li><p>确定海明码的位数，由上述 n 与 k 的关系，可知 n = 4,得k = 3，设信息位为<strong>D<sub>4</sub>D<sub>3</sub>D<sub>2</sub>D<sub>1</sub></strong>(1010)，共 4 位，校验位 P<sub>1</sub>P<sub>2</sub>P<sub>3</sub> 共 3 位，对应海明码为 H<sub>7</sub>H<sub>6</sub>H<sub>5</sub>H<sub>4</sub>H<sub>3</sub>H<sub>2</sub>H<sub>1</sub> 。</p></li><li><p>确定校验位的分布：校验位 P<sub>i</sub> 放在海明位号为2<sup>i-1</sup>的位置上，信息位按顺序放到其余位置。</p><table><thead><tr><th>H<sub>7</sub></th><th>H<sub>6</sub></th><th>H<sub>5</sub></th><th>H<sub>4</sub></th><th>H<sub>3</sub></th><th>H<sub>2</sub></th><th>H<sub>1</sub></th></tr></thead><tbody><tr><td>D<sub>4</sub></td><td>D<sub>3</sub></td><td>D<sub>2</sub></td><td>P<sub>3</sub></td><td>D<sub>1</sub></td><td>P<sub>2</sub></td><td>P<sub>1</sub></td></tr><tr><td>1</td><td>0</td><td>1</td><td><u>0</u></td><td>0</td><td><u>1</u></td><td><u>0</u></td></tr></tbody></table></li><li><p>分组以形成校验关系</p><p>每个数据位用多个校验位进行校验，且应满足条件：<strong>被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。</strong></p><p>所以D<sub>1</sub>应该由 P<sub>2 </sub>P<sub>1 </sub>校验，D<sub>2</sub>应该由 P<sub>3 </sub>P<sub>1 </sub>校验，D<sub>3</sub>应该由 P<sub>3 </sub>P<sub>2 </sub>校验，D<sub>4</sub>应该由 P<sub>3 </sub>P<sub>2 </sub>P<sub>1 </sub>校验</p><p>故分组如下：</p><ul><li>第 1 组：P<sub>1 </sub>D<sub>1</sub> D<sub>2</sub> D<sub>4</sub> （D<sub>1</sub> D<sub>2</sub> D<sub>4</sub> 都被 P<sub>1</sub> 所检验 ）</li><li>第 2 组：P<sub>2 </sub>D<sub>1</sub> D<sub>3</sub> D<sub>4</sub> （D<sub>1</sub> D<sub>3</sub> D<sub>4</sub> 都被 P<sub>2</sub> 所检验 ）</li><li>第 3 组：P<sub>3 </sub>D<sub>2</sub> D<sub>3</sub> D<sub>4</sub> （D<sub>2</sub> D<sub>3</sub> D<sub>4</sub> 都被 P<sub>3</sub> 所检验 ）</li></ul></li><li><p>求校验位的值：（可采用下图所示的方法）</p></li></ol><center><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207161718268.png" style="zoom:80%;" /></center><ol start="4"><li>纠错</li></ol><p>（1）接收到：1010010</p><table><thead><tr><th>H<sub>7</sub></th><th>H<sub>6</sub></th><th>H<sub>5</sub></th><th>H<sub>4</sub></th><th>H<sub>3</sub></th><th>H<sub>2</sub></th><th>H<sub>1</sub></th></tr></thead><tbody><tr><td>D<sub>4</sub></td><td>D<sub>3</sub></td><td>D<sub>2</sub></td><td>P<sub>3</sub></td><td>D<sub>1</sub></td><td>P<sub>2</sub></td><td>P<sub>1</sub></td></tr><tr><td>1</td><td>0</td><td>1</td><td><u>0</u></td><td>0</td><td><u>1</u></td><td><u>0</u></td></tr></tbody></table><p>校验方程：<br>$$<br>S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0<br>$$</p><p>$$<br>S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus 0 \oplus 1 = 0<br>$$</p><p>$$<br>S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 0 \oplus 1 = 0<br>$$<br>数据无错误</p><p>（2）接收到1<u>1</u>10010（D<sub>3 </sub>发生了跳变）</p><p>校验方程：<br>$$<br>S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0<br>$$</p><p>$$<br>S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus \underline1 \oplus 1 = 1<br>$$</p><p>$$<br>S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus \underline1 \oplus 1 = 1<br>$$</p><p>那么 我们由 S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 可以得到错误的位置为第6位(H<sub>6</sub>)，即D<sub>3 </sub>发生了错误</p><p><strong>Question: 为何可以通过S<sub>3</sub>S<sub>2</sub>S<sub>1</sub>得到错误的位置？为何不是S<sub>1</sub>S<sub>2</sub>S<sub>3</sub>？</strong></p><div class="note info flat"><p>Answer: 我们分别把 P<sub>3</sub>P<sub>2</sub>P<sub>1 </sub> 放到 421 的位置（把 P<sub>i</sub> 放在2<sup>i-1</sup>的位置），我们可以把它理解成一种权重，与海明位号二进制表示的各个权重是一一对应的！回顾一下上面求校验位值的过程，校验方程 S<sub>i</sub> 中包含的校验位即是 P<sub>i</sub> ，按从大到小的权重排列即是：S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> 。所以上述发生了错误对于各校验方程的值： S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 ，即指出错误的位置为第6位(H<sub>6</sub>)，即D<sub>3 </sub>发生了错误。</p></div><center><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207161718268.png"  /></center><h4 id="（补充）海明码的检错、纠错能力"><a href="#（补充）海明码的检错、纠错能力" class="headerlink" title="（补充）海明码的检错、纠错能力"></a>（补充）海明码的检错、纠错能力</h4><p>纠错能力 —— 1位</p><p>检错能力 —— 2位</p><ol><li><p>但是海明码<strong>无法区分是1位错还是2位错</strong>，还是上面的例子，S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 ，错误的位置一定为第6位？还可以是P<sub>3</sub>P<sub>2</sub>发生了错误对不对www</p></li><li><p>为了区分 1 位错和 2 位错，常添加“全校验位”对整体进行偶校验。</p><p> S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 000 且全体偶校验成功 → 无错误</p><p> S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> ≠ 000 且全体偶校验失败 → 有1位错，纠正即可</p><p> S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> ≠ 000 且全体偶校验成功 → 有2位错，需重传</p><table><thead><tr><th align="center">H<sub>8</sub></th><th align="center">H<sub>7</sub></th><th align="center">H<sub>6</sub></th><th align="center">H<sub>5</sub></th><th align="center">H<sub>4</sub></th><th align="center">H<sub>3</sub></th><th align="center">H<sub>2</sub></th><th align="center">H<sub>1</sub></th></tr></thead><tbody><tr><td align="center">P<sub>全</sub></td><td align="center">D<sub>4</sub></td><td align="center">D<sub>3</sub></td><td align="center">D<sub>2</sub></td><td align="center">P<sub>3</sub></td><td align="center">D<sub>1</sub></td><td align="center">P<sub>2</sub></td><td align="center">P<sub>1</sub></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center"><u>0</u></td><td align="center">0</td><td align="center"><u>1</u></td><td align="center"><u>0</u></td></tr></tbody></table></li></ol><h3 id="循环冗余校验码（CRC码）"><a href="#循环冗余校验码（CRC码）" class="headerlink" title="循环冗余校验码（CRC码）"></a>循环冗余校验码（CRC码）</h3><h4 id="循环冗余校验码的基本思想"><a href="#循环冗余校验码的基本思想" class="headerlink" title="循环冗余校验码的基本思想"></a>循环冗余校验码的基本思想</h4><ol><li><p>数据发送、接受方约定一个“除数” </p></li><li><p>K个信息位 + R个校验位 作为“被除数”，添加校验位后需保证除法的余数为0</p></li><li><p>收到数据后，进行除法检查余数是否为0，若余数非0说明出错，则进行重传或纠错</p></li></ol><center><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207174813942.png" style="zoom: 80%;" /></center><p>例如：</p><center><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207174754144.png" style="zoom: 67%;" /></center><h4 id="CRC码求解步骤"><a href="#CRC码求解步骤" class="headerlink" title="CRC码求解步骤"></a>CRC码求解步骤</h4><p>eg.1 设生成多项式为<em>G</em>(<em>x</em>)=<em>x</em><sup>3</sup>+<em>x</em><sup>2</sup>+1，信息码为101001，求对应的CRC码。</p><ol><li><p>确定K、R以及生成多项式对应的二进制码</p><p> K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3 –→ 校验码位数 N = K + R = 9</p><p> 生成多项式<em>G</em>(<em>x</em>)=1·<em>x</em><sup>3 </sup> + 1·<em>x</em><sup>2</sup>+ 0·x + 1，对应二进制码<strong>1101</strong></p></li><li><p>移位，信息码左移R位，低位补0</p></li><li><p>相除，对移位后的信息码，用生成多项式进行模2除法，产生余数（注意体会“模2除”、“模2减”）</p></li></ol><center><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207180100532.png"  /></center><p>对应的CRC码：101001 001</p><ol start="4"><li>检错和纠错</li></ol><p>  发送：101001001，记为C<sub>9</sub>C<sub>8</sub>C<sub>7</sub>C<sub>6</sub>C<sub>5</sub>C<sub>4</sub>C<sub>3</sub>C<sub>2</sub>C<sub>1</sub><br>  接收：101001001</p><p>  用1101进行模2除 → 余数为000，代表没有出错</p><p>  接收：101001011<br>  用1101进行模2除 → 余数为010，代表C<sub>2</sub>出错</p>]]></content>
    
    
    <summary type="html">进位计数制、BCD码、字符与字符串、校验码</summary>
    
    
    
    <category term="计算机组成原理" scheme="https://serein.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="学习" scheme="https://serein.fun/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用Magpie来增加你的游戏体验！</title>
    <link href="https://serein.fun/2021/12/02/magpie/"/>
    <id>https://serein.fun/2021/12/02/magpie/</id>
    <published>2021-12-01T16:07:08.000Z</published>
    <updated>2022-02-21T01:09:25.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FSR算法和Anime4K算法"><a href="#FSR算法和Anime4K算法" class="headerlink" title="FSR算法和Anime4K算法"></a>FSR算法和Anime4K算法</h2><h3 id="FSR"><a href="#FSR" class="headerlink" title="FSR"></a>FSR</h3><p>​    AMD FidelityFX Super Resolution，简称FSR，中文名称是“AMD超级分辨率锐画技术”。就是使用超分辨率技术实现高分辨率，高品质游戏画面，并显著提高游戏运行效率的一套实现方法和程序库。它免费开源，跨平台，针对硬件进行了优化，集成到程序也非常简单（实际上只有两个文件），最神奇的是，运行它并不需要特殊的硬件，甚至如前几代的Intel CPU内集成的核显，都可以使用该技术。FSR算法正式开源后，FSR技术的源代码、开发文档、实例都已经放在了AMD GPUOpen网站上，开发者可以直接用于他们的游戏。AMD目前提供的实例支持DX12、Vulkan，但保证说编译着色器也兼容DX11。</p><p>​    AMD还表示，FSR技术不像NVIDIA DLSS那样依赖于运动向量(Motion Vector)或者历史缓冲区(History Buffer)，因此不需要专门的Tensor核心来加速，但同样也能使用时间数据，只是现阶段FSR的重心是简化开发、快速推向市场，技术上会逐步深入增强。来看看FSR的实际表现：</p><p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012549359.png"></p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012310018.png" style="zoom: 80%;" /><h3 id="Anime4K"><a href="#Anime4K" class="headerlink" title="Anime4K"></a>Anime4K</h3><p>​    当你在看老番或是在推一部老物 gal &amp; avg ，是否在为其画质差而发愁？Anime4K（动漫图片超分辨率算法）即是一个实时、视频动画放大算法，不用等待处理视频动画的时间，在你观看的同时即可做到画质提升，在一周内，Anime4K在Github上收获了将近3千颗星，作者在6天前介绍了reddit上的项目，并成为每个人的热门话题，引起了极大的关注。引用一下作者原话：</p><div class="note info flat"><p>Anime4K is a set of open-source, high-quality real-time anime upscaling/denoising algorithms that can be implemented in any programming language.</p><p>The simplicity and speed of Anime4K allows the user to watch upscaled anime in real time, as we believe in preserving original content and promoting freedom of choice for all anime fans. Re-encoding anime into 4K should be avoided as it is non-reversible, potentially damages original content by introducing artifacts, takes up to O(n<sup>2</sup>) more disk space and more importantly, does so without any meaningful decrease in entropy (lost information is lost).</p></div><p>​    附上开源项目原地址：<i class="fa fa-link" aria-hidden="true"></i> <a href="https://github.com/bloc97/Anime4K">https://github.com/bloc97/Anime4K</a></p><p>​    将其导入到支持的视频软件后，便可以享受1080P升级到近4K的画质了，来看看使用具体表现！</p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012627278.png" style="zoom: 50%;" /><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012707750.png" style="zoom: 50%;" /><hr><h2 id="使用Magpie提高游戏体验"><a href="#使用Magpie提高游戏体验" class="headerlink" title="使用Magpie提高游戏体验"></a>使用Magpie提高游戏体验</h2><p>开源项目地址：<i class="fa fa-link" aria-hidden="true"></i> <a href="https://github.com/Blinue/Magpie/tree/v0.7.1">https://github.com/Blinue/Magpie/tree/v0.7.1</a></p><blockquote><p>Magpie 可以将任意窗口放大至全屏，支持多种高级缩放算法，包括 Lanczos、<a href="https://github.com/bloc97/Anime4K">Anime4K</a>、<a href="https://github.com/GPUOpen-Effects/FidelityFX-FSR">FSR</a>、<a href="https://github.com/igv/FSRCNN-TensorFlow">FSRCNNX</a>等。</p><p>主要用于游戏窗口的放大显示，适用于不支持全屏模式，或者内置的全屏模式会使画面模糊的情况。</p></blockquote><p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204013127026.png"></p><p>上面提到的两个算法，Magpie全部支持，不能全屏的老游戏都可以全屏，还可以使用Anime4K算法让其<del>全部变为4K画质？</del>（当然不可能全部提升到4K，但观感比原生画质好太多。当然游戏和动画的画质低，提升效果也就相对较差，720P以上的游戏提升效果会比较好！1080P提升后与4K观感相差无几，涂抹感很少。</p><p>当然，使用算法实时渲染提升画质，对显卡来说是有性能要求的，所以要想畅玩享受全屏清晰画质的 anime &amp; gal 的话，一个相对来说好点显卡是必须的。</p><p>对于提升游戏帧数来说，不同游戏的体验不同，实际使用Magpie支持的FSR算法体验不算很好，期待以后算法的改善。</p>]]></content>
    
    
    <summary type="html">AMD FidelityFX Super Resolution，简称FSR，中文名称是“AMD超级分辨率锐画技术”</summary>
    
    
    
    <category term="工具" scheme="https://serein.fun/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://serein.fun/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
