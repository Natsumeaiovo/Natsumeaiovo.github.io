<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用Magpie来增加你的游戏体验！</title>
    <url>/2021/12/02/magpie/</url>
    <content><![CDATA[<h2 id="FSR算法和Anime4K算法"><a href="#FSR算法和Anime4K算法" class="headerlink" title="FSR算法和Anime4K算法"></a>FSR算法和Anime4K算法</h2><span id="more"></span>

<h3 id="FSR"><a href="#FSR" class="headerlink" title="FSR"></a>FSR</h3><p>​    AMD FidelityFX Super Resolution，简称FSR，中文名称是“AMD超级分辨率锐画技术”。就是使用超分辨率技术实现高分辨率，高品质游戏画面，并显著提高游戏运行效率的一套实现方法和程序库。它免费开源，跨平台，针对硬件进行了优化，集成到程序也非常简单（实际上只有两个文件），最神奇的是，运行它并不需要特殊的硬件，甚至如前几代的Intel CPU内集成的核显，都可以使用该技术。FSR算法正式开源后，FSR技术的源代码、开发文档、实例都已经放在了AMD GPUOpen网站上，开发者可以直接用于他们的游戏。AMD目前提供的实例支持DX12、Vulkan，但保证说编译着色器也兼容DX11。</p>
<p>​    AMD还表示，FSR技术不像NVIDIA DLSS那样依赖于运动向量(Motion Vector)或者历史缓冲区(History Buffer)，因此不需要专门的Tensor核心来加速，但同样也能使用时间数据，只是现阶段FSR的重心是简化开发、快速推向市场，技术上会逐步深入增强。来看看FSR的实际表现：</p>
<p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012549359.png" alt="image-20211204012549359"></p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012310018.png" alt="image-20211204012310018" style="zoom: 80%;" />


<h3 id="Anime4K"><a href="#Anime4K" class="headerlink" title="Anime4K"></a>Anime4K</h3><p>​    当你在看老番或是在推一部老物 gal &amp; avg ，是否在为其画质差而发愁？Anime4K（动漫图片超分辨率算法）即是一个实时、视频动画放大算法，不用等待处理视频动画的时间，在你观看的同时即可做到画质提升，在一周内，Anime4K在Github上收获了将近3千颗星，作者在6天前介绍了reddit上的项目，并成为每个人的热门话题，引起了极大的关注。引用一下作者原话：</p>
<blockquote>
<p>Anime4K is a set of open-source, high-quality real-time anime upscaling/denoising algorithms that can be implemented in any programming language.</p>
<p>The simplicity and speed of Anime4K allows the user to watch upscaled anime in real time, as we believe in preserving original content and promoting freedom of choice for all anime fans. Re-encoding anime into 4K should be avoided as it is non-reversible, potentially damages original content by introducing artifacts, takes up to O(n<sup>2</sup>) more disk space and more importantly, does so without any meaningful decrease in entropy (lost information is lost).</p>
</blockquote>
<p>​    附上开源项目原地址：<i class="fa fa-link" aria-hidden="true"></i> <a href="https://github.com/bloc97/Anime4K">https://github.com/bloc97/Anime4K</a></p>
<p>​    将其导入到支持的视频软件后，便可以享受1080P升级到近4K的画质了，来看看使用具体表现！</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012627278.png" alt="image-20211204012627278" style="zoom: 50%;" />

<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012707750.png" alt="image-20211204012707750" style="zoom: 50%;" />

<hr>
<h2 id="使用Magpie提高游戏体验"><a href="#使用Magpie提高游戏体验" class="headerlink" title="使用Magpie提高游戏体验"></a>使用Magpie提高游戏体验</h2><p>开源项目地址：<i class="fa fa-link" aria-hidden="true"></i> <a href="https://github.com/Blinue/Magpie/tree/v0.7.1">https://github.com/Blinue/Magpie/tree/v0.7.1</a></p>
<blockquote>
<p>Magpie 可以将任意窗口放大至全屏，支持多种高级缩放算法，包括 Lanczos、<a href="https://github.com/bloc97/Anime4K">Anime4K</a>、<a href="https://github.com/GPUOpen-Effects/FidelityFX-FSR">FSR</a>、<a href="https://github.com/igv/FSRCNN-TensorFlow">FSRCNNX</a>等。</p>
<p>主要用于游戏窗口的放大显示，适用于不支持全屏模式，或者内置的全屏模式会使画面模糊的情况。</p>
</blockquote>
<p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204013127026.png" alt="image-20211204013127026"></p>
<p>上面提到的两个算法，Magpie全部支持，不能全屏的老游戏都可以全屏，还可以使用Anime4K算法让其<del>全部变为4K画质？</del>（当然不可能全部提升到4K，但观感比原生画质好太多😂</p>
<p>当然游戏和动画的画质低，提升效果也就相对较差，720P以上的游戏提升效果会比较好！1080P提升后与4K观感相差无几，涂抹感很少。</p>
<p>当然，使用算法实时渲染提升画质，对显卡来说是有性能要求的，所以要想畅玩享受全屏清晰画质的 anime &amp; gal 的话，一个相对来说好点显卡是必须的。</p>
<p>对于提升游戏帧数来说，不同游戏的体验不同，实际使用Magpie支持的FSR算法体验不算很好，期待以后算法的改善。</p>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树四种遍历的非递归方式</title>
    <url>/2021/12/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、前序、中序和后序遍历"><a href="#一、前序、中序和后序遍历" class="headerlink" title="一、前序、中序和后序遍历"></a>一、前序、中序和后序遍历</h2><span id="more"></span>
<h3 id="需用到栈："><a href="#需用到栈：" class="headerlink" title="需用到栈："></a>需用到栈：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span></span><br><span class="hljs-class">&#123;</span><br>    BiTree data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; StackNode, *LinkStackPtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    LinkStackPtr top;<br>    <span class="hljs-keyword">int</span> count;<br>&#125; LinkStack;<br><br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack *S)</span></span><br><span class="hljs-function"></span>&#123;<br>    S-&gt;top = <span class="hljs-literal">NULL</span>;<br>    S-&gt;count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack *S, BiTree e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == e)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    LinkStackPtr s = (LinkStackPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(StackNode));   <span class="hljs-comment">//s指向新栈结点的指针</span><br>    s-&gt;data = e;<br>    s-&gt;next = S-&gt;top; <span class="hljs-comment">/* 把当前的栈顶元素赋值给新结点的直接后继 */</span><br>    S-&gt;top = s;       <span class="hljs-comment">/* 将新的结点s赋值给栈顶指针 */</span><br>    S-&gt;count++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack *S, BiTree *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkStackPtr p;<br>    <span class="hljs-keyword">if</span> ((*S).count == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    *e = S-&gt;top-&gt;data;<br>    p = S-&gt;top;            <span class="hljs-comment">/* 将栈顶结点赋值给p */</span><br>    S-&gt;top = S-&gt;top-&gt;next; <span class="hljs-comment">/* 使得栈顶指针下移一位，指向后一结点 */</span><br>    <span class="hljs-built_in">free</span>(p);               <span class="hljs-comment">/* 释放结点p */</span><br>    S-&gt;count--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack S, BiTree &amp;p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">else</span><br>        p = S.top-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="前序遍历实现："><a href="#前序遍历实现：" class="headerlink" title="前序遍历实现："></a>前序遍历实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//*  初始条件：二叉树T存在</span><br><span class="hljs-comment">//todo  操作结果：前序非递归遍历T</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraverse_2</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkStack S;<br>    <span class="hljs-built_in">InitStack</span>(&amp;S);<br>    BiTree p = T;<br>    <span class="hljs-keyword">while</span>(p || S.count != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)        <span class="hljs-comment">//?  左子树不为空</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, p-&gt;data);<br>            <span class="hljs-built_in">Push</span>(&amp;S, p);    <span class="hljs-comment">//?  栈存放各子树的右子树</span><br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">Pop</span>(&amp;S, &amp;p);<br>            p = p-&gt;rchild;<br>        &#125;<br>    &#125;<span class="hljs-comment">//?  当左子树为空，且栈空，退出循环</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="中序遍历实现："><a href="#中序遍历实现：" class="headerlink" title="中序遍历实现："></a>中序遍历实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//*  初始条件：二叉树T存在</span><br><span class="hljs-comment">//todo  操作结果：中序非递归遍历T</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraverse_2</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkStack S;<br>    <span class="hljs-built_in">InitStack</span>(&amp;S);<br>    BiTree p = T;<br>    <span class="hljs-keyword">while</span>(p || S.count != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)        <span class="hljs-comment">//?  左子树不为空</span><br>        &#123;<br>            <span class="hljs-built_in">Push</span>(&amp;S, p);    <span class="hljs-comment">//?  栈存放各子树的根结点</span><br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-comment">//?  左子树空，弹出栈顶元素并输出，转为右子树继续循环</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">Pop</span>(&amp;S, &amp;p);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,p-&gt;data);<br>            p = p-&gt;rchild;<br>        &#125;<br>    &#125;<span class="hljs-comment">//?  当左子树为空，且栈空，退出循环</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="后序遍历实现："><a href="#后序遍历实现：" class="headerlink" title="后序遍历实现："></a>后序遍历实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//*  初始条件：二叉树T存在</span><br><span class="hljs-comment">//todo  操作结果：后序非递归遍历T</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraverse_2</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree p = T, r = <span class="hljs-literal">NULL</span>;<br>    LinkStack S;<br>    <span class="hljs-built_in">InitStack</span>(&amp;S);<br>    <span class="hljs-keyword">while</span>(p || S.count != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)        <span class="hljs-comment">//todo  走到最左边</span><br>        &#123;<br>            <span class="hljs-built_in">Push</span>(&amp;S, p);<br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">GetTop</span>(S, p);<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)        <span class="hljs-comment">//*  若右子树存在, 且未被访问过</span><br>                p = p-&gt;rchild;        <span class="hljs-comment">//todo 转向右边</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">Pop</span>(&amp;S, &amp;p);<br>                <span class="hljs-built_in">visit</span>(p-&gt;data);<br>                r = p;        <span class="hljs-comment">//*  记录最近访问过的结点</span><br>                p = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//?  将p置空</span><br>            &#125;<br>        &#125;<span class="hljs-comment">//else</span><br>    &#125;<span class="hljs-comment">//while</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二、层次遍历"><a href="#二、层次遍历" class="headerlink" title="二、层次遍历"></a>二、层次遍历</h2><h3 id="需用到队列："><a href="#需用到队列：" class="headerlink" title="需用到队列："></a>需用到队列：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    BiTree *data;<br>    <span class="hljs-keyword">int</span> front; <span class="hljs-comment">/* 头指针 */</span><br>    <span class="hljs-keyword">int</span> rear;  <span class="hljs-comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span><br>&#125; SqQueue;<br><br><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span><br><span class="hljs-function"></span>&#123;<br>    Q.data = (BiTree *)<span class="hljs-built_in">malloc</span>((MAXSIZE+<span class="hljs-number">1</span>) * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BiTree));<br>    <span class="hljs-keyword">if</span>(!Q.data)<br>        <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    Q.front = <span class="hljs-number">0</span>;<br>    Q.rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, BiTree e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ((Q.rear + <span class="hljs-number">1</span>) % MAXSIZE == Q.front) <span class="hljs-comment">/* 队列满的判断 */</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    Q.data[Q.rear] = e;              <span class="hljs-comment">/* 将元素e赋值给队尾 */</span><br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXSIZE; <span class="hljs-comment">/* rear指针向后移一位置， */</span><br>                                       <span class="hljs-comment">/* 若到最后则转到数组头部 */</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, BiTree &amp;e)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front == Q.rear) <span class="hljs-comment">/* 队列空的判断 */</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    e = Q.data[Q.front];              <span class="hljs-comment">/* 将队头元素赋值给e */</span><br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXSIZE; <span class="hljs-comment">/* front指针向后移一位置， */</span><br>                                         <span class="hljs-comment">/* 若到最后则转到数组头部 */</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">QueueEmpty</span><span class="hljs-params">(SqQueue Q)</span></span><br></code></pre></td></tr></table></figure>

<h3 id="层次遍历实现"><a href="#层次遍历实现" class="headerlink" title="层次遍历实现"></a>层次遍历实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//todo  操作结果：层次遍历T </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree p;<br>    SqQueue qu;    <span class="hljs-comment">//使用队列来层次遍历二叉树</span><br>    <span class="hljs-built_in">InitQueue</span>(qu);<br>    <span class="hljs-built_in">EnQueue</span>(qu, T);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(qu))        <span class="hljs-comment">//队列非空/*  */</span><br>    &#123;<br>        <span class="hljs-built_in">DeQueue</span>(qu, p);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, p-&gt;data);<br>        <span class="hljs-keyword">if</span>(p-&gt;lchild)<br>            <span class="hljs-built_in">EnQueue</span>(qu, p-&gt;lchild);<br>        <span class="hljs-keyword">if</span>(p-&gt;rchild)<br>            <span class="hljs-built_in">EnQueue</span>(qu, p-&gt;rchild);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数制与编码</title>
    <url>/2021/12/03/%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="一、进位计数制"><a href="#一、进位计数制" class="headerlink" title="一、进位计数制"></a>一、进位计数制</h2><span id="more"></span>


<p>二进制 &lt;–&gt; 八进制：  3位一组</p>
<p>二进制 &lt;–&gt; 十六进制  4位一组</p>
<p>十进制 –&gt; 任意进制</p>
<p>整数部分：除基取余法</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204011910835.png" alt="image-20211204011910835" style="zoom: 80%;" />

<p>小数部分：乘基取整法</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204013540140.png" alt="image-20211204013540140" style="zoom: 67%;" />

<p><strong>真值：符合人类习惯的数字，如+15、-8等</strong></p>
<p><strong>机器数：数字实际存到机器里的形式，正负号需要被“数字化”。常用的有原码、补码和反码表示法。</strong></p>
<hr>
<h2 id="二、BCD码"><a href="#二、BCD码" class="headerlink" title="二、BCD码"></a>二、BCD码</h2><p>二进制编码的十进制数（Binary-Coded Decimal, BCD）通常采用 4 位二进制数来表示一位十进制数中的 0~9 这10个编码。这种编码方法使二进制数和十进制数之间的转换得意快速进行。但4位二进制数可以组合出 2<sup>4</sup> 种代码，因此必有 6 种状态为冗余。列举几种常用BCD码：</p>
<h3 id="8421码（最常用）"><a href="#8421码（最常用）" class="headerlink" title="8421码（最常用）"></a>8421码（最常用）</h3><p>是一种有权码，权值从高到低依次为8,4,2,1，下图为其映射关系</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">0010</td>
<td align="center">0011</td>
<td align="center">0100</td>
<td align="center">0101</td>
<td align="center">0110</td>
<td align="center">0111</td>
<td align="center">1000</td>
<td align="center">1001</td>
</tr>
</tbody></table>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204105204096.png" alt="image-20211204105204096" style="zoom: 80%;" />

<p>注：若相加结果在合法范围内，则无需修正。</p>
<h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><p>余3码 = 8421码 + (0011)</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0011</td>
<td align="center">0100</td>
<td align="center">0101</td>
<td align="center">0110</td>
<td align="center">0111</td>
<td align="center">1000</td>
<td align="center">1001</td>
<td align="center">1010</td>
<td align="center">1011</td>
<td align="center">1100</td>
</tr>
</tbody></table>
<h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><p>2421码改变了权值定义，四位二进制码对应权值从高到低依次为2,4,2,1，并且规定：表示0-4时，最高位为0；表示5-9时最高位为1。</p>
<p>映射关系如下：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">0010</td>
<td align="center">0011</td>
<td align="center">0100</td>
<td align="center">1011</td>
<td align="center">1100</td>
<td align="center">1101</td>
<td align="center">1110</td>
<td align="center">1111</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、字符与字符串"><a href="#三、字符与字符串" class="headerlink" title="三、字符与字符串"></a>三、字符与字符串</h2><h3 id="字符编码与ASCII码"><a href="#字符编码与ASCII码" class="headerlink" title="字符编码与ASCII码"></a>字符编码与ASCII码</h3><p>数字 + 字母 + 符号 = 共128个字符 -&gt; 7位二进制编码（2<sup>7</sup> = 128）-&gt; ASCII码</p>
<p>每个字节的最高位保持为 0，可用于传输时的奇偶校验位。下图为ASCII字符代码表：</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204112630157.png" alt="image-20211204112630157" style="zoom: 80%;" />

<p><em>其中：</em></p>
<p><em>可印刷字符：32～126，其余为控制、通信字符</em></p>
<p><em>数字：48(0011 0000)～57(0011 1001)</em></p>
<p><em>大写字母：65(0100 0001)～90(0101 1010)</em></p>
<p><em>小写字母：97(0110 0001)～122(0111 1010)</em></p>
<h3 id="汉字的表示与编码"><a href="#汉字的表示与编码" class="headerlink" title="汉字的表示与编码"></a>汉字的表示与编码</h3><ol>
<li><p><strong>汉字编码：</strong>包括汉字的输入编码、汉字内码、汉字字形码三种，是在计算机中用于输入、内部处理和输出三种用途的编码。</p>
</li>
<li><p><strong>区位码：</strong>区位要分开看，是区码和位码的组合。用两个字节表示一个汉字，每字节用七位码，将汉字和图形符号排列在一个 94 行 94 列的二维代码表中。区位码是 4 位十进制数，前 2 位是区码，后 2 位是位码，所以称为区位码。</p>
<table>
<thead>
<tr>
<th align="center">区码\位码</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">…</th>
<th align="center">94</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">94</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p><strong>国际码：</strong>将十进制的区位码转换为十六进制数后，再在每字节上加上 20H 。国际码两字节的最高位都是 0 ，ASCII码的最高位也是 0 。</p>
<blockquote>
<p>（为什么要加入2020H呢？）ASCII码表前32（20H）位 0 - 31 都是用于通信和控制的字符，加上2020H后，可以防止信息交换时与“控制/通信字符”冲突。</p>
</blockquote>
</li>
<li><p><strong>汉字内码：</strong>为了方便计算机区分中文字符和英文字符，将国际码两字节的最高位都改为”1”，这就是汉字内码。要保证最高位为“1”，所以要加上8080H。（注意是在国际码基础上 + 8080H）</p>
</li>
</ol>
<p>区位码和国际码都是输入码，它们和汉字内码的关系（十六进制）如下：</p>
<p><strong>国际码 = （区位码）<sub>16</sub> + 2020H</strong></p>
<p><strong>汉字内码 = （国际码）<sub>16</sub> + 8080H</strong></p>
<hr>
<h2 id="四、校验码"><a href="#四、校验码" class="headerlink" title="四、校验码"></a>四、校验码</h2><p><strong>码字：</strong>由若干位代码组成的一个字叫码字。</p>
<p><strong>校验码：</strong>指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。</p>
<p><strong>码距：</strong>将两个码字逐位进行对比，具有<strong>不同的位的个数</strong>称为两个码字间的<strong>距离</strong>。一种编码方案可能有若干个合法码字，各合法码字间的<strong>最小距离</strong>称为“码距”。（如 1100 和 1101 之间的码距为 1，因为只有最低位翻转了。而1001和0010之间的码距则为3，因为只有1位没有变化）</p>
<p>当d=1时，无检错能力；当d=2时，有检错能力；当d≥3时，若设计合理，可能具有检错、纠错能力。</p>
<p><strong>码距越大，检错、纠错的能力就越强，而且检错能力总是大于等于纠错能力。</strong></p>
<p>对于检错、纠错能力与码距的具体关系如下：（e,t 为整数）<br>$$<br>码距 \geq e + 1; (可检测 e 个错误)<br>$$</p>
<p>$$<br>码距 \geq 2t + 1； (可纠正 t 个错误)<br>$$</p>
<p>$$<br>码距 \geq e + t + 1 (e \geq t)； (可检测 e 个错误，同时纠正 t 个错误) (想要增加检测数量，则需要减少纠正数量)<br>$$</p>
<p><em>码距越大，抗干扰能力越强，纠错能力越强，但数据冗余越大，编码效率低，编码电路也相对复杂。</em></p>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ul>
<li>奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数。</li>
<li>偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数。</li>
</ul>
<p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204143620554.png" alt="image-20211204143620554"></p>
<p>eg.给出两个编码1001101和1010111的奇校验码和偶校验码。</p>
<p>解：设最高位为校验位，余7位是信息位，则对应的奇偶校验码为：</p>
<p>奇校验： <u>1</u>1001101 ····· <u>0</u>1010111 （异或结果为0说明出错）</p>
<p>偶校验： <u>0</u>1001101 ····· <u>1</u>1010111 （异或结果为1说明出错）</p>
<p>上面我们可以数出“1”的个数来得到对应的奇偶校验码，那么<strong>机器</strong>是如何得到奇偶校验检错码的呢？？（采用异或操作）</p>
<p>对于机器，它算出的(这里注意<strong>指误码</strong>并不是<strong>校验位</strong>，注意区分S和P的含义)</p>
<p>奇校验<strong>指误码</strong>：<br>$$<br>S_奇 = \overline{P \oplus X_1\oplus X_2\oplus X_3\oplus …\oplus X_n}<br>$$<br>偶校验<strong>指误码</strong>：<br>$$<br>S_偶 = P \oplus X_1\oplus X_2\oplus X_3\oplus …\oplus X_n<br>$$<br>$$<br>X_1,X_2,…,X_n表示被校验的数据，P为校验位，当S_{奇/偶} = 0表示数据正常(并不可证明数据无错误!)，否则表示出错<br>$$</p>
<p><strong>Question: 奇/偶校验码的码距为？</strong></p>
<blockquote>
<p>Answer：<strong>一定为2。</strong>一般地，比如8421码：0000，0001，…，1111，奇偶校验就是一个码组（如8421）内的任意2个有效编码间的不同位数（因为是任意的2个，所以在8421中取0000和0001只有1位不同），码距为1。加上奇偶校验后，使1的个数变为奇数或偶数（如0001变00010为奇，变00011为偶），此码组都这样编码（奇校验：00001，00010，…，11111）码距最小为2。</p>
</blockquote>
<p><strong>缺点：</strong>具有局限性，只能发现数据代码出错位的个数为<strong>奇数情况下的错误</strong>，比如2个或4个或2n个位都出错了，此时校验失效。而且不能确定是哪一位出错。只有1个校验位，故只能携带 true or false 2种状态信息，<strong>只能检测奇数个错误，不能纠正错误</strong>。</p>
<p>到这里你可能会有个疑问(゜▽゜？)，为什么奇偶校验码的码距为2，却可以检测出1、3、…、2n + 1 个错误呢？公式不是说好了应该只能检测出1个错误嘛？↓<br>$$<br>码距 \geq e + 1; (可检测 e 个错误)<br>$$</p>
<ul>
<li>其实并不矛盾，我们来看看码距的定义：<em>一种编码方案可能有若干个合法码字，各合法码字间的<strong>最小距离</strong>称为“码距”。</em>我们举例一种编码方案例如：0001,0010,0100,1100 显然这个编码方案的码距为 2 ，那么可以知道，这组码字如果出现一个错误，都可以检测出来，例如第一个码字出现错误00<u>1</u>1，那么00<u>1</u>1就不在此编码方案中，检测到错误。如果出现3个错误，例如第一个码字变为了<u>11</u>0<u>0</u>，那么它即与最后一个码字是相同的，不能检测出错误。</li>
<li>为什么奇偶校验码码距也为2，可以检测出奇数个错误呢？上述的编码方案，它并不是奇偶校验码，码字“1100”有偶数个“1”。区别就在这里！假如编码方案变为：0001,0010,0100,1000，这样每个码字都是奇校验码，当发生了3（or 2n+1）个错误，那么那个码字一定会变成偶数个“1”，所以说上述公式是针对一般码字而言的。</li>
</ul>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>海明校验：</p>
<ul>
<li>是一种多重分组奇偶校验</li>
<li>将代码组织为若干分组，每组进行奇偶校验</li>
<li>能够检验是否出错，并能定位出错位</li>
</ul>
<h4 id="海明码设计思路"><a href="#海明码设计思路" class="headerlink" title="海明码设计思路"></a>海明码设计思路</h4><p>待编码信息n位，分成k组，每组1各校验位</p>
<p>校验码位数：k位</p>
<p>海明编码总长：N = n + k位</p>
<p>海明编码时：各组单独进行奇偶校验编码，以确定各组的校验位。</p>
<p>代码检验时：每组能产生1个指误码 <strong>S</strong> </p>
<ul>
<li>r位指误码 比如：S<sub>3</sub>S<sub>2</sub>S<sub>1</sub>S<sub>0</sub></li>
<li>2<sup>r</sup>种可能的指误代码，如0000、0001、0010、…</li>
</ul>
<p>指误码 S 全为 0  &hArr; 海明编码无错，其余(2<sup>k</sup>-1)种情况均表示编码出错<br>$$<br>而各参数应满足：N = n + k \leq 2^k - 1<br>$$<br>例如k = 4，则需要r&gt;=3满足上述定理，可组成7位海明码，n和k的一些对应取值关系：</p>
<table>
<thead>
<tr>
<th align="left">n</th>
<th align="left">1</th>
<th>2-4</th>
<th>5-11</th>
<th>12-26</th>
<th>27-57</th>
<th>58-120</th>
</tr>
</thead>
<tbody><tr>
<td align="left">k</td>
<td align="left">2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody></table>
<h4 id="海明码求解步骤"><a href="#海明码求解步骤" class="headerlink" title="海明码求解步骤"></a>海明码求解步骤</h4><p>举例：信息位为1010</p>
<ol>
<li><p>确定海明码的位数，由上述 n 与 k 的关系，可知 n = 4,得k = 3，设信息位为<strong>D<sub>4</sub>D<sub>3</sub>D<sub>2</sub>D<sub>1</sub></strong>(1010)，共 4 位，校验位 P<sub>1</sub>P<sub>2</sub>P<sub>3</sub> 共 3 位，对应海明码为 H<sub>7</sub>H<sub>6</sub>H<sub>5</sub>H<sub>4</sub>H<sub>3</sub>H<sub>2</sub>H<sub>1</sub> 。</p>
</li>
<li><p>确定校验位的分布：校验位 P<sub>i</sub> 放在海明位号为2<sup>i-1</sup>的位置上，信息位按顺序放到其余位置。</p>
<table>
<thead>
<tr>
<th>H<sub>7</sub></th>
<th>H<sub>6</sub></th>
<th>H<sub>5</sub></th>
<th>H<sub>4</sub></th>
<th>H<sub>3</sub></th>
<th>H<sub>2</sub></th>
<th>H<sub>1</sub></th>
</tr>
</thead>
<tbody><tr>
<td>D<sub>4</sub></td>
<td>D<sub>3</sub></td>
<td>D<sub>2</sub></td>
<td>P<sub>3</sub></td>
<td>D<sub>1</sub></td>
<td>P<sub>2</sub></td>
<td>P<sub>1</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td><u>0</u></td>
<td>0</td>
<td><u>1</u></td>
<td><u>0</u></td>
</tr>
</tbody></table>
</li>
<li><p>分组以形成校验关系</p>
<p>每个数据位用多个校验位进行校验，且应满足条件：<strong>被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。</strong></p>
<p>所以D<sub>1</sub>应该由 P<sub>2 </sub>P<sub>1 </sub>校验，D<sub>2</sub>应该由 P<sub>3 </sub>P<sub>1 </sub>校验，D<sub>3</sub>应该由 P<sub>3 </sub>P<sub>2 </sub>校验，D<sub>4</sub>应该由 P<sub>3 </sub>P<sub>2 </sub>P<sub>1 </sub>校验</p>
<p>故分组如下：</p>
<ul>
<li>第 1 组：P<sub>1 </sub>D<sub>1</sub> D<sub>2</sub> D<sub>4</sub> （D<sub>1</sub> D<sub>2</sub> D<sub>4</sub> 都被 P<sub>1</sub> 所检验 ）</li>
<li>第 2 组：P<sub>2 </sub>D<sub>1</sub> D<sub>3</sub> D<sub>4</sub> （D<sub>1</sub> D<sub>3</sub> D<sub>4</sub> 都被 P<sub>2</sub> 所检验 ）</li>
<li>第 3 组：P<sub>3 </sub>D<sub>2</sub> D<sub>3</sub> D<sub>4</sub> （D<sub>2</sub> D<sub>3</sub> D<sub>4</sub> 都被 P<sub>3</sub> 所检验 ）</li>
</ul>
</li>
<li><p>求校验位的值：（可采用下图所示的方法）</p>
<p> <img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207161718268.png" alt="image-20211207161718268"></p>
</li>
<li><p>纠错</p>
</li>
</ol>
<p>（1）接收到：1010010</p>
<table>
<thead>
<tr>
<th>H<sub>7</sub></th>
<th>H<sub>6</sub></th>
<th>H<sub>5</sub></th>
<th>H<sub>4</sub></th>
<th>H<sub>3</sub></th>
<th>H<sub>2</sub></th>
<th>H<sub>1</sub></th>
</tr>
</thead>
<tbody><tr>
<td>D<sub>4</sub></td>
<td>D<sub>3</sub></td>
<td>D<sub>2</sub></td>
<td>P<sub>3</sub></td>
<td>D<sub>1</sub></td>
<td>P<sub>2</sub></td>
<td>P<sub>1</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td><u>0</u></td>
<td>0</td>
<td><u>1</u></td>
<td><u>0</u></td>
</tr>
</tbody></table>
<p>校验方程：<br>$$<br>S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0<br>$$</p>
<p>$$<br>S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus 0 \oplus 1 = 0<br>$$</p>
<p>$$<br>S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 0 \oplus 1 = 0<br>$$<br>数据无错误</p>
<p>（2）接收到1<u>1</u>10010（D<sub>3 </sub>发生了跳变）</p>
<p>校验方程：<br>$$<br>S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0<br>$$</p>
<p>$$<br>S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus \underline1 \oplus 1 = 1<br>$$</p>
<p>$$<br>S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus \underline1 \oplus 1 = 1<br>$$</p>
<p>那么 我们由 S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 可以得到错误的位置为第6位(H<sub>6</sub>)，即D<sub>3 </sub>发生了错误</p>
<p><strong>Question: 为何可以通过S<sub>3</sub>S<sub>2</sub>S<sub>1</sub>得到错误的位置？为何不是S<sub>1</sub>S<sub>2</sub>S<sub>3</sub>？</strong></p>
<blockquote>
<p>Answer: 我们分别把 P<sub>3</sub>P<sub>2</sub>P<sub>1 </sub> 放到 421 的位置（把 P<sub>i</sub> 放在2<sup>i-1</sup>的位置），我们可以把它理解成一种权重，与海明位号二进制表示的各个权重是一一对应的！回顾一下上面求校验位值的过程：</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207161718268.png" alt="image-20211207161718268" style="zoom: 67%;" />

<p>校验方程 S<sub>i</sub> 中包含的校验位即是 P<sub>i</sub> ，按从大到小的权重排列即是：S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> 。所以上述发生了错误对于各校验方程的值： S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 ，即指出错误的位置为第6位(H<sub>6</sub>)，即D<sub>3 </sub>发生了错误。</p>
</blockquote>
<h4 id="（补充）海明码的检错、纠错能力"><a href="#（补充）海明码的检错、纠错能力" class="headerlink" title="（补充）海明码的检错、纠错能力"></a>（补充）海明码的检错、纠错能力</h4><p>纠错能力 —— 1位</p>
<p>检错能力 —— 2位</p>
<ol>
<li><p>但是海明码<strong>无法区分是1位错还是2位错</strong>，还是上面的例子，S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 ，错误的位置一定为第6位？还可以是P<sub>3</sub>P<sub>2</sub>发生了错误对不对www</p>
</li>
<li><p>为了区分 1 位错和 2 位错，常添加“全校验位”对整体进行偶校验。</p>
<table>
<thead>
<tr>
<th>H<sub>8</sub></th>
<th>H<sub>7</sub></th>
<th>H<sub>6</sub></th>
<th>H<sub>5</sub></th>
<th>H<sub>4</sub></th>
<th>H<sub>3</sub></th>
<th>H<sub>2</sub></th>
<th>H<sub>1</sub></th>
</tr>
</thead>
<tbody><tr>
<td>P<sub>全</sub></td>
<td>D<sub>4</sub></td>
<td>D<sub>3</sub></td>
<td>D<sub>2</sub></td>
<td>P<sub>3</sub></td>
<td>D<sub>1</sub></td>
<td>P<sub>2</sub></td>
<td>P<sub>1</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td><u>0</u></td>
<td>0</td>
<td><u>1</u></td>
<td><u>0</u></td>
</tr>
</tbody></table>
</li>
</ol>
<p>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 000 且全体偶校验成功 –→ 无错误</p>
<p>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> ≠ 000 且全体偶校验失败 –→ 有1位错，纠正即可</p>
<p>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> ≠ 000 且全体偶校验成功 –→ 有2位错，需重传</p>
<h3 id="循环冗余校验码（CRC码）"><a href="#循环冗余校验码（CRC码）" class="headerlink" title="循环冗余校验码（CRC码）"></a>循环冗余校验码（CRC码）</h3><h4 id="循环冗余校验码的基本思想"><a href="#循环冗余校验码的基本思想" class="headerlink" title="循环冗余校验码的基本思想"></a>循环冗余校验码的基本思想</h4><ol>
<li><p>数据发送、接受方约定一个“除数” </p>
</li>
<li><p>K个信息位 + R个校验位 作为“被除数”，添加校验位后需保证除法的余数为0</p>
</li>
<li><p>收到数据后，进行除法检查余数是否为0，若余数非0说明出错，则进行重传或纠错</p>
</li>
</ol>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207174813942.png" alt="image-20211207174813942" style="zoom: 80%;" />

<p>例如：</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207174754144.png" alt="image-20211207174754144" style="zoom: 67%;" />



<h4 id="CRC码求解步骤"><a href="#CRC码求解步骤" class="headerlink" title="CRC码求解步骤"></a>CRC码求解步骤</h4><p>eg.1 设生成多项式为<em>G</em>(<em>x</em>)=<em>x</em><sup>3</sup>+<em>x</em><sup>2</sup>+1，信息码为101001，求对应的CRC码。</p>
<ol>
<li><p>确定K、R以及生成多项式对应的二进制码</p>
<p> K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3 –→ 校验码位数 N = K + R = 9</p>
<p> 生成多项式<em>G</em>(<em>x</em>)=1·<em>x</em><sup>3 </sup> + 1·<em>x</em><sup>2</sup>+ 0·x + 1，对应二进制码<strong>1101</strong></p>
</li>
<li><p>移位，信息码左移R位，低位补0</p>
</li>
<li><p>相除，对移位后的信息码，用生成多项式进行模2除法，产生余数（注意体会“模2除”、“模2减”）</p>
<p> <img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207180100532.png" alt="image-20211207180100532"></p>
<p> 对应的CRC码：101001 001</p>
</li>
<li><p>检错和纠错</p>
</li>
</ol>
<p>  发送：101001001，记为C<sub>9</sub>C<sub>8</sub>C<sub>7</sub>C<sub>6</sub>C<sub>5</sub>C<sub>4</sub>C<sub>3</sub>C<sub>2</sub>C<sub>1</sub><br>  接收：101001001</p>
<p>  用1101进行模2除 –→ 余数为000，代表没有出错</p>
<p>  接收：101001011<br>  用1101进行模2除 –→ 余数为010，代表C<sub>2</sub>出错</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>找到二叉树给定两结点的共同祖先</title>
    <url>/2021/12/26/%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%99%E5%AE%9A%E4%B8%A4%E7%BB%93%E7%82%B9%E7%9A%84%E5%85%B1%E5%90%8C%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><span id="more"></span>

<h3 id="如何得到一个给定结点的所有祖先？"><a href="#如何得到一个给定结点的所有祖先？" class="headerlink" title="如何得到一个给定结点的所有祖先？"></a>如何得到一个给定结点的所有祖先？</h3><p>我们很容易想到后序遍历，利用栈实现后序遍历时，遍历到某结点时，栈中所有元素即该结点祖先。</p>
<p>那么找出给定结点的所有祖先的算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//todo  输出x的所有祖先</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Anc_Print</span><span class="hljs-params">(BiTree T, TElemType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree p = T, r = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//r先用来标记右子树是否被访问过</span><br>    SqStack S; InitSqStack(S); <span class="hljs-comment">//初始化栈</span><br>    <span class="hljs-keyword">while</span>(p || S.top != <span class="hljs-number">-1</span>)    <span class="hljs-comment">//进行后序遍历</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)    <span class="hljs-comment">//一直入栈直到树的左下</span><br>        &#123;<br>            SqPush(S, p);<br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">//  转为右子树</span><br>        &#123;<br>            SqGetTop(S, p);<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)    <span class="hljs-comment">// 右子树存在且没被访问过</span><br>                p = p-&gt;rchild;    <span class="hljs-comment">//转向</span><br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">//  右子树不存在或被访问过了</span><br>            &#123;<br>                SqPop(S, p);<br>                <span class="hljs-keyword">if</span>(p-&gt;data == x)<br>                    <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//找到值为x的结点，退出循环</span><br>                r = p;<br>                p = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(S.top != <span class="hljs-number">-1</span>)    <span class="hljs-comment">//输出所有祖先</span><br>    &#123;<br>        SqPop(S, p);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c  &quot;</span>,p-&gt;data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何找到两结点共同点祖先？"><a href="#如何找到两结点共同点祖先？" class="headerlink" title="如何找到两结点共同点祖先？"></a>如何找到两结点共同点祖先？</h3><p>由上面的过程，我们不难想到，后序遍历到某结点时，栈S中所有元素即该结点祖先。遍历到p或q时，将栈S中元素复制到一辅助栈S1里，再继续遍历到另一所求结点，那么从栈S栈顶开始逐个到辅助栈S1中去匹配，第一个匹配的结点即最近祖先。</p>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><ol>
<li><p>首先我们希望输入想要找的结点的值，就能通过此值定向到该结点（树中所有结点data域均不同），从而去寻找共同祖先，那么首先我们需要指向data域等于我们input值的指针，可以通过如下代码实现：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//todo 找到指向x的指针</span><br><span class="hljs-function">BiTree <span class="hljs-title">Find_x</span><span class="hljs-params">(BiTree T, TElemType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;data == x)<br>        <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Find_x</span>(T-&gt;lchild, x))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find_x</span>(T-&gt;lchild, x);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">Find_x</span>(T-&gt;rchild, x);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过上述思想，将共同祖先保存到r：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Ancestor</span><span class="hljs-params">(BiTree T, BiTree p, BiTree q, BiTree &amp;r)</span>  <span class="hljs-comment">//最后将最近共同祖先保存到 r</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree temp = T, x = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//? temp为工作指针;先找到p,则x指向q,先找到q,则x指向p</span><br>    r = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//? r先用来标记右子树是否被访问过</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, tag = <span class="hljs-number">0</span>;    <span class="hljs-comment">//?  tag记录是否找到了p或q(此时栈S1中已复制完成)</span><br>    SqStack S; <span class="hljs-built_in">InitSqStack</span>(S);<br>    SqStack S1; <span class="hljs-built_in">InitSqStack</span>(S1);<br>    <span class="hljs-keyword">while</span>(temp || S.top != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(temp)    <span class="hljs-comment">//? 一直入栈直到树的左下</span><br>        &#123;<br>            <span class="hljs-built_in">SqPush</span>(S, temp);<br>            temp = temp-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">//?  转为右子树</span><br>        &#123;<br>            <span class="hljs-built_in">SqGetTop</span>(S, temp);<br>            <span class="hljs-keyword">if</span>(temp-&gt;rchild &amp;&amp; temp-&gt;rchild != r) <span class="hljs-comment">//? 右子树存在且没被访问过</span><br>                temp = temp-&gt;rchild;    <span class="hljs-comment">//转向</span><br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">//?  右子树不存在或被访问过了</span><br>            &#123;<br>                <span class="hljs-built_in">SqPop</span>(S, temp);        <span class="hljs-comment">//* 将栈顶结点出栈，让 temp指向它</span><br>                <span class="hljs-keyword">if</span>(!tag &amp;&amp; (temp == p || temp == q))    <span class="hljs-comment">//*  tag = 1时，说明已找到p或者q,所以此if下语句全程只会执行一次</span><br>                &#123;<br>                    x = temp==p ? q : p;<br>                    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt;= S.top; i++)<br>                        S1.data[i] = S.data[i];<br>                    S1.top = S.top;<br>                    tag = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp == x)<br>                    <span class="hljs-keyword">break</span>;<br>                r = temp;<br>                temp = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i0 = i;  <span class="hljs-comment">//i0存放S1的栈顶</span><br>    j = S.top;<br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)    <span class="hljs-comment">//栈S从栈顶开始，从辅助栈S1中逐个寻找相同元素</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; S.data[j] != S1.data[i])<br>            i--;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            i = i0;  <span class="hljs-comment">//i重新指向栈顶</span><br>            j--;  <span class="hljs-comment">//继续从栈S下一个元素开始逐个与S1匹配</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">//i&gt;=0说明匹配成功，退出循环</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)<br>        r = S1.data[i];<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">//如果i&lt;0，则寻找失败，无共同祖先</span><br>        r = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>返回指向r的指针（考虑到上面算法会出错的情况并完善）：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BiTree <span class="hljs-title">ComAnc_Node</span><span class="hljs-params">(BiTree T, TElemType p, TElemType q)</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree r, n1, n2;<br>    n1 = <span class="hljs-built_in">Find_x</span>(T, p);<br>    n2 = <span class="hljs-built_in">Find_x</span>(T, q);<br>    <span class="hljs-keyword">if</span>(!n1 || !n2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(p==T-&gt;data || q==T-&gt;data)<br>        <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-built_in">Ancestor</span>(T, n1, n2, r);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>试运行：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">int</span> i;<br>    BiTree T,Tnew,com_anc;<br>    TElemType e1;<br>    <span class="hljs-built_in">InitBiTree</span>(&amp;T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化二叉树后,树空否？\n%d(1:是 0:否) 树的深度=%d\n&quot;</span>, <span class="hljs-built_in">BiTreeEmpty</span>(T), <span class="hljs-built_in">BiTreeDepth</span>(T));<br>    <span class="hljs-built_in">StrAssign</span>(str, <span class="hljs-string">&quot;ABDH#K###E##CFI###G#J##&quot;</span>);<br>    <span class="hljs-comment">//按前序输入</span><br>    <span class="hljs-built_in">CreateBiTree</span>(&amp;T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;构造二叉树后,树空否？\n%d(1:是 0:否) 树的深度=%d\n&quot;</span>, <span class="hljs-built_in">BiTreeEmpty</span>(T), <span class="hljs-built_in">BiTreeDepth</span>(T));<br>    e1 = <span class="hljs-built_in">Root</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;二叉树的根为: %c\n&quot;</span>, e1);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;树的高度:%d\n&quot;</span>, <span class="hljs-built_in">BtDepth_2</span>(T));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n前序递归遍历二叉树T:&quot;</span>);<br>    <span class="hljs-built_in">PreOrderTraverse</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n中序递归遍历二叉树T:&quot;</span>);<br>    <span class="hljs-built_in">InOrderTraverse</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n后序递归遍历二叉树T:&quot;</span>);<br>    <span class="hljs-built_in">PostOrderTraverse</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n    层次遍历二叉树T:&quot;</span>);<br>    <span class="hljs-built_in">LevelOrderTraverse</span>(T);<br>    com_anc = <span class="hljs-built_in">ComAnc_Node</span>(T, <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(com_anc)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最近祖先为：%c\n&quot;</span>, com_anc-&gt;data);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入不合法或无共同祖先\n&quot;</span>);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 运行结果：</p>
<p> <img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211226020646165.png" alt="image-20211226020646165"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>计算机</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
