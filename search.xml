<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>初步理解红黑树</title>
    <url>/2022/01/15/RB-Tree/</url>
    <content><![CDATA[<h2 id="为何需要红黑树？"><a href="#为何需要红黑树？" class="headerlink" title="为何需要红黑树？"></a>为何需要红黑树？</h2><p>平衡二叉树 AVL：插入/删除 很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行 LL/RR/LR/RL 调整。适用于以查为主、很少插入/删除的场景。</p>
<p>红黑树 RBT：插入/删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一般都可以在常数级时间内完成。适用于频繁插入、删除的场景，实用性更强。</p>
<h2 id="红黑树的定义与性质"><a href="#红黑树的定义与性质" class="headerlink" title="红黑树的定义与性质"></a>红黑树的定义与性质</h2><p>红黑树结点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RBnode</span>&#123;</span>       <span class="hljs-comment">//红黑树的结点定义</span><br>    <span class="hljs-keyword">int</span> key;         <span class="hljs-comment">//关键字的值</span><br>    RBnode* parent;  <span class="hljs-comment">//父结点指针</span><br>    RBnode* lchild;  <span class="hljs-comment">//左孩子指针</span><br>    RBnode* rchild;  <span class="hljs-comment">//右孩子指针</span><br>    <span class="hljs-keyword">int</span> color;       <span class="hljs-comment">//结点颜色，如：可用 0/1 表示 黑/红，也可使用枚举型enum表示颜色</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>红黑树是二叉排序树，满足左子树结点值 ≤ 根结点值 ≤ 右子树结点值。</p>
</li>
<li><p>与普通BST相比，有什么性质？</p>
<p>①每个结点或是红色，或是黑色的</p>
<p>②根节点是黑色的</p>
<p>③叶结点（外部结点、NULL结点、失败结点）均是黑色的</p>
<p>④不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</p>
<p>⑤对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</p>
<p>实例：一颗红黑树</p>
<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220115203316375.png" style="zoom:40%;" /></li>
</ol>
<div class="note note-info">
            <p>结点的黑高 bh ：从某结点出发（不含该结点）到达任一空叶结点（含叶结点）的路径上黑结点总数。</p>
          </div>

<p><strong>思考：</strong>根节点黑高为 h 的红黑树，内部结点数（关键字）至少有多少个？</p>
<p>Answer：内部结点数最少的情况——总共h层黑结点的满树形态，即：</p>
<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116150104977.png" style="zoom: 80%;" />

<p>结论：若根节点黑高为h，内部结点数（关键字）最少有 2<sup>h</sup>-1 个</p>
<p>进而有如下结论：</p>
<ul>
<li>结论1：从根节点到叶结点的最长路径不大于最短路径的2倍</li>
<li>结论2：有n个内部节点的红黑树高度 h ≤ 2$log_2 (n+1)$</li>
</ul>
<p>→ 红黑树查找操作时间复杂度 = $O(log_2 (n))$</p>
<p>性质1很容易证明，这里写下结论2的证明：</p>
<p><strong>证明：</strong>由结论1可知，从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为h/2，于是有n ≥ 2<sup>h/2</sup> - 1，即可求得结论。</p>
<p>可见，红黑树的“适度平衡”，由AVL树的“高度平衡”，降低到“任一结点左右子树的高度，相差不超过2倍”，也降低了动态操作，也降低了动态操作时调整的频率。对于一颗动态查找树，如果插入和删除操作比较少，查找操作比较多，采用AVL树比较合适，否则采用红黑树更合适。但由于维护这种高度平衡所付出的代价比获得的效益大得多，红黑树的实际应用更广泛，C++中的 map 和 set （Java 中的 TreeMap 和 TreeSet）就是用红黑树实现的。</p>
<h2 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h2><p>先查找，确定插入位置（原理同二叉排序树），插入新结点</p>
<ul>
<li><p>新结点是<strong>根</strong>——染为黑色</p>
</li>
<li><p>新结点<strong>非根</strong>——染为红色</p>
<ul>
<li><p>若插入新结点后依然满足红黑树定义，则插入结束</p>
</li>
<li><p>若插入新结点后不满足红黑树定义，需要调整，使其重新满足红黑树定义</p>
<ul>
<li>黑叔：旋转+染色<ul>
<li>LL型：右单旋，父换爷+染色</li>
<li>RR型：左单旋，父换爷+染色</li>
<li>LR型：左、右双旋，儿换爷+染色</li>
<li>RL型：右、左双旋，儿换爷+染色</li>
</ul>
</li>
<li>红叔：染色+变新 <ul>
<li>叔父爷染色，爷变为新结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>例：</strong>从一棵空的红黑树开始，插入：20, 10, 5, 30, 40, 57, 3, 2, 4, 35, 25, 18, 22, 23, 24, 19, 18 </p>
<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116000500362.png" style="zoom: 45%;" />

<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116001531379.png" style="zoom:45%;" />

<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116002640320.png" style="zoom:45%;" />

<p>…</p>
<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116002829660.png" style="zoom:80%;" />

<p>一直重复上述操作，最终得到：</p>
<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116002935419.png" style="zoom:45%;" />

<h2 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h2><h3 id="1-删除红结点"><a href="#1-删除红结点" class="headerlink" title="1. 删除红结点"></a>1. 删除红结点</h3><p>对于删除红结点，其不会破坏红黑树原有的性质。<strong>第一</strong>，根结点到任意叶结点的黑结点数量不变，不会破坏红黑树的黑高；<strong>其次</strong>，删除红结点，不会有相邻的红结点出现，因为红结点的子结点总是黑色。删除红结点过程中，红结点可以分为：</p>
<ul>
<li>没有子结点</li>
<li>一个子结点</li>
<li>两个子结点</li>
</ul>
<p>此时，直接应用AVL树中删除结点的方法，对其进行删除，过程不再赘述。问题只剩下删除黑结点。</p>
<h3 id="2-删除黑结点"><a href="#2-删除黑结点" class="headerlink" title="2. 删除黑结点"></a>2. 删除黑结点</h3><p>删除黑结点的过程繁琐得多，主要分为以下情况：</p>
<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116225206937.png" style="zoom:45%;" />

<p>问题：“我”的一个黑色子结点被删除了，经调整后<strong>我和我的我的子树“1”构成的树已满足红黑树的性质，但是“父P”的左子树的黑高 -1</strong> ，如何修复整颗红黑树的性质？</p>
<p>对于如下不同情形的方案：</p>
<h4 id="（1）哥黑，双侄黑，父黑"><a href="#（1）哥黑，双侄黑，父黑" class="headerlink" title="（1）哥黑，双侄黑，父黑"></a>（1）哥黑，双侄黑，父黑</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116232723116.png" style="zoom:50%;" />

<p><strong>方案：</strong>将哥S染红，问题解决。</p>
<h4 id="（2）哥黑，双侄黑，父红"><a href="#（2）哥黑，双侄黑，父红" class="headerlink" title="（2）哥黑，双侄黑，父红"></a>（2）哥黑，双侄黑，父红</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116225805164.png" style="zoom:50%;" />

<p><strong>方案：</strong>直接将父P和哥S换色，问题解决。</p>
<h4 id="（3）哥黑，顺侄红（逆侄色任意，父色任意）"><a href="#（3）哥黑，顺侄红（逆侄色任意，父色任意）" class="headerlink" title="（3）哥黑，顺侄红（逆侄色任意，父色任意）"></a>（3）哥黑，顺侄红（逆侄色任意，父色任意）</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116231511669.png" style="zoom: 50%;" />

<p><strong>方案：</strong>①首先对父P进行左旋；②将父P与哥S的颜色交换；③将顺侄染为黑色。问题解决。</p>
<h4 id="（4）哥黑，顺侄黑，逆侄红（父色任意）"><a href="#（4）哥黑，顺侄黑，逆侄红（父色任意）" class="headerlink" title="（4）哥黑，顺侄黑，逆侄红（父色任意）"></a>（4）哥黑，顺侄黑，逆侄红（父色任意）</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116234653862.png" style="zoom:50%;" />

<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116233420377.png" style="zoom:50%;" />

<p><strong>方案：</strong>①首先对哥S进行右旋，发现逆侄左子树“2”与右子树黑高不同；②将逆侄与哥S颜色互换，得到情形（3）。问题递归。</p>
<h4 id="（5）哥红"><a href="#（5）哥红" class="headerlink" title="（5）哥红"></a>（5）哥红</h4><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116235630256.png" style="zoom:50%;" />

<img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220116235738368.png" style="zoom:50%;" />

<p><strong>方案：</strong>①对父P进行左旋，发现哥S左右子树黑高不一致；②将父P和哥S颜色互换。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1FS4y1976h/">https://www.bilibili.com/video/BV1FS4y1976h/</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1uZ4y1P7rr/">https://www.bilibili.com/video/BV1uZ4y1P7rr/</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数制与编码</title>
    <url>/2021/12/03/Number-system-coding/</url>
    <content><![CDATA[<h2 id="一、进位计数制"><a href="#一、进位计数制" class="headerlink" title="一、进位计数制"></a>一、进位计数制</h2><p>二进制 → 八进制：  3位一组</p>
<p>二进制 → 十六进制  4位一组</p>
<p>十进制 → 任意进制</p>
<p>整数部分：除基取余法</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204011910835.png" style="zoom: 80%;" />

<p>小数部分：乘基取整法</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204013540140.png" style="zoom: 67%;" />

<p><strong>真值：符合人类习惯的数字，如+15、-8等</strong></p>
<p><strong>机器数：数字实际存到机器里的形式，正负号需要被“数字化”。常用的有原码、补码和反码表示法。</strong></p>
<hr>
<h2 id="二、BCD码"><a href="#二、BCD码" class="headerlink" title="二、BCD码"></a>二、BCD码</h2><p>二进制编码的十进制数（Binary-Coded Decimal, BCD）通常采用 4 位二进制数来表示一位十进制数中的 0~9 这10个编码。这种编码方法使二进制数和十进制数之间的转换得意快速进行。但4位二进制数可以组合出 2<sup>4</sup> 种代码，因此必有 6 种状态为冗余。列举几种常用BCD码：</p>
<h3 id="8421码（最常用）"><a href="#8421码（最常用）" class="headerlink" title="8421码（最常用）"></a>8421码（最常用）</h3><p>是一种有权码，权值从高到低依次为8,4,2,1，下图为其映射关系</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">0010</td>
<td align="center">0011</td>
<td align="center">0100</td>
<td align="center">0101</td>
<td align="center">0110</td>
<td align="center">0111</td>
<td align="center">1000</td>
<td align="center">1001</td>
</tr>
</tbody></table>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204105204096.png" style="zoom: 80%;" />

<p>注：若相加结果在合法范围内，则无需修正。</p>
<h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><p>余3码 = 8421码 + (0011)</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0011</td>
<td align="center">0100</td>
<td align="center">0101</td>
<td align="center">0110</td>
<td align="center">0111</td>
<td align="center">1000</td>
<td align="center">1001</td>
<td align="center">1010</td>
<td align="center">1011</td>
<td align="center">1100</td>
</tr>
</tbody></table>
<h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><p>2421码改变了权值定义，四位二进制码对应权值从高到低依次为2,4,2,1，并且规定：表示0-4时，最高位为0；表示5-9时最高位为1。</p>
<p>映射关系如下：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">0010</td>
<td align="center">0011</td>
<td align="center">0100</td>
<td align="center">1011</td>
<td align="center">1100</td>
<td align="center">1101</td>
<td align="center">1110</td>
<td align="center">1111</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、字符与字符串"><a href="#三、字符与字符串" class="headerlink" title="三、字符与字符串"></a>三、字符与字符串</h2><h3 id="字符编码与ASCII码"><a href="#字符编码与ASCII码" class="headerlink" title="字符编码与ASCII码"></a>字符编码与ASCII码</h3><p>数字 + 字母 + 符号 = 共128个字符 -&gt; 7位二进制编码（2<sup>7</sup> = 128）-&gt; ASCII码</p>
<p>每个字节的最高位保持为 0，可用于传输时的奇偶校验位。下图为ASCII字符代码表：</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204112630157.png" style="zoom: 80%;" />

<p>其中：</p>
<p>可印刷字符：32～126，其余为控制、通信字符</p>
<p>数字：48(0011 0000)～57(0011 1001)</p>
<p>大写字母：65(0100 0001)～90(0101 1010)</p>
<p>小写字母：97(0110 0001)～122(0111 1010)</p>
<h3 id="汉字的表示与编码"><a href="#汉字的表示与编码" class="headerlink" title="汉字的表示与编码"></a>汉字的表示与编码</h3><ol>
<li><p><strong>汉字编码：</strong>包括汉字的输入编码、汉字内码、汉字字形码三种，是在计算机中用于输入、内部处理和输出三种用途的编码。</p>
</li>
<li><p><strong>区位码：</strong>区位要分开看，是区码和位码的组合。用两个字节表示一个汉字，每字节用七位码，将汉字和图形符号排列在一个 94 行 94 列的二维代码表中。区位码是 4 位十进制数，前 2 位是区码，后 2 位是位码，所以称为区位码。</p>
<table>
<thead>
<tr>
<th align="center">区码\位码</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">…</th>
<th align="center">94</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">94</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p><strong>国际码：</strong>将十进制的区位码转换为十六进制数后，再在每字节上加上 20H 。国际码两字节的最高位都是 0 ，ASCII码的最高位也是 0 。</p>
<div class="note note-success">
            <p>（为什么要加入2020H呢？）ASCII码表前32（20H）位 0 - 31 都是用于通信和控制的字符，加上2020H后，可以防止信息交换时与“控制/通信字符”冲突。</p>
          </div></li>
<li><p><strong>汉字内码：</strong>为了方便计算机区分中文字符和英文字符，将国际码两字节的最高位都改为”1”，这就是汉字内码。要保证最高位为“1”，所以要加上8080H。（注意是在国际码基础上 + 8080H）</p>
</li>
</ol>
<p>区位码和国际码都是输入码，它们和汉字内码的关系（十六进制）如下：</p>
<p><strong>国际码 = （区位码）<sub>16</sub> + 2020H</strong></p>
<p><strong>汉字内码 = （国际码）<sub>16</sub> + 8080H</strong></p>
<hr>
<h2 id="四、校验码"><a href="#四、校验码" class="headerlink" title="四、校验码"></a>四、校验码</h2><p><strong>码字：</strong>由若干位代码组成的一个字叫码字。</p>
<p><strong>校验码：</strong>指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。</p>
<p><strong>码距：</strong>将两个码字逐位进行对比，具有<strong>不同的位的个数</strong>称为两个码字间的<strong>距离</strong>。一种编码方案可能有若干个合法码字，各合法码字间的<strong>最小距离</strong>称为“码距”。（如 1100 和 1101 之间的码距为 1，因为只有最低位翻转了。而1001和0010之间的码距则为3，因为只有1位没有变化）</p>
<p>当d=1时，无检错能力；当d=2时，有检错能力；当d≥3时，若设计合理，可能具有检错、纠错能力。</p>
<p><strong>码距越大，检错、纠错的能力就越强，而且检错能力总是大于等于纠错能力。</strong></p>
<p>对于检错、纠错能力与码距的具体关系如下：（e,t 为整数）<br>码距 $\geq e + 1; $(可检测 e 个错误)<br>码距 $\geq 2t + 1; $(可纠正 t 个错误)<br>码距 $\geq e + t + 1 (e \geq t); $(可检测 e 个错误，同时纠正 t 个错误) (想要增加检测数量，则需要减少纠正数量)</p>
<p>码距越大，抗干扰能力越强，纠错能力越强，但数据冗余越大，编码效率低，编码电路也相对复杂。</p>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><ul>
<li>奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数。</li>
<li>偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数。</li>
</ul>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204143620554.png" style="zoom:80%;" />

<p>eg.给出两个编码1001101和1010111的奇校验码和偶校验码。</p>
<p>解：设最高位为校验位，余7位是信息位，则对应的奇偶校验码为：</p>
<p>奇校验： <u>1</u>1001101 ····· <u>0</u>1010111 （异或结果为0说明出错）</p>
<p>偶校验： <u>0</u>1001101 ····· <u>1</u>1010111 （异或结果为1说明出错）</p>
<p>上面我们可以数出“1”的个数来得到对应的奇偶校验码，那么<strong>机器</strong>是如何得到奇偶校验检错码的呢？？（采用异或操作）</p>
<p>对于机器，它算出的(这里注意<strong>指误码</strong>并不是<strong>校验位</strong>，注意区分S和P的含义)</p>
<p>奇校验<strong>指误码</strong>：<br>$$<br>S_奇 = \overline{P \oplus X_1\oplus X_2\oplus X_3\oplus …\oplus X_n}<br>$$<br>偶校验<strong>指误码</strong>：<br>$$<br>S_偶 = P \oplus X_1\oplus X_2\oplus X_3\oplus …\oplus X_n<br>$$</p>
<p>$X_1,X_2,…,X_n$ 表示被校验的数据，P为校验位，当$S_{奇/偶} = 0$表示数据正常(并不可证明数据无错误!)，否则表示出错</p>
<p><strong>Question: 奇/偶校验码的码距为？</strong></p>
<div class="note note-info">
            <p>Answer：<strong>一定为2。</strong>一般地，比如8421码：0000，0001，…，1111，奇偶校验就是一个码组（如8421）内的任意2个有效编码间的不同位数（因为是任意的2个，所以在8421中取0000和0001只有1位不同），码距为1。加上奇偶校验后，使1的个数变为奇数或偶数（如0001变00010为奇，变00011为偶），此码组都这样编码（奇校验：00001，00010，…，11111）码距最小为2。</p>
          </div>
<p><strong>缺点：</strong>具有局限性，只能发现数据代码出错位的个数为<strong>奇数情况下的错误</strong>，比如2个或4个或2n个位都出错了，此时校验失效。而且不能确定是哪一位出错。只有1个校验位，故只能携带 true or false 2种状态信息，<strong>只能检测奇数个错误，不能纠正错误</strong>。</p>
<p>到这里你可能会有个疑问，为什么奇偶校验码的码距为2，却可以检测出1、3、…、2n + 1 个错误呢？公式不是说好了应该只能检测出1个错误吗？↓</p>
<div class="note note-info">
            <p>码距 $\geq e + 1; $(可检测 e 个错误)</p>
          </div>

<ul>
<li>其实并不矛盾，我们来看看码距的定义：<strong>一种编码方案可能有若干个合法码字，各合法码字间的最小距离称为“码距”。</strong>我们举例一种编码方案例如：0001,0010,0100,1100 显然这个编码方案的码距为 2 ，那么可以知道，这组码字如果出现一个错误，都可以检测出来，例如第一个码字出现错误00<u>1</u>1，那么00<u>1</u>1就不在此编码方案中，检测到错误。如果出现3个错误，例如第一个码字变为了<u>11</u>0<u>0</u>，那么它即与最后一个码字是相同的，不能检测出错误。</li>
<li>为什么奇偶校验码码距也为2，可以检测出奇数个错误呢？上述的编码方案，它并不是奇偶校验码，码字“1100”有偶数个“1”。区别就在这里！假如编码方案变为：0001,0010,0100,1000，这样每个码字都是奇校验码，当发生了3（or 2n+1）个错误，那么那个码字一定会变成偶数个“1”，所以说上述公式是针对一般码字而言的。</li>
</ul>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>海明校验：</p>
<ul>
<li>是一种多重分组奇偶校验</li>
<li>将代码组织为若干分组，每组进行奇偶校验</li>
<li>能够检验是否出错，并能定位出错位</li>
</ul>
<h4 id="海明码设计思路"><a href="#海明码设计思路" class="headerlink" title="海明码设计思路"></a>海明码设计思路</h4><p>待编码信息n位，分成k组，每组1各校验位</p>
<p>校验码位数：k位</p>
<p>海明编码总长：N = n + k位</p>
<p>海明编码时：各组单独进行奇偶校验编码，以确定各组的校验位。</p>
<p>代码检验时：每组能产生1个指误码 <strong>S</strong> </p>
<ul>
<li>r位指误码 比如：S<sub>3</sub>S<sub>2</sub>S<sub>1</sub>S<sub>0</sub></li>
<li>2<sup>r</sup>种可能的指误代码，如0000、0001、0010、…</li>
</ul>
<p>指误码 S 全为 0  &hArr; 海明编码无错，其余(2<sup>k</sup>-1)种情况均表示编码出错</p>
<p>而各参数应满足：$N = n + k \leq 2^k - 1$</p>
<p>例如k = 4，则需要r&gt;=3满足上述定理，可组成7位海明码，n和k的一些对应取值关系：</p>
<table>
<thead>
<tr>
<th align="left">n</th>
<th align="left">1</th>
<th>2-4</th>
<th>5-11</th>
<th>12-26</th>
<th>27-57</th>
<th>58-120</th>
</tr>
</thead>
<tbody><tr>
<td align="left">k</td>
<td align="left">2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody></table>
<h4 id="海明码求解步骤"><a href="#海明码求解步骤" class="headerlink" title="海明码求解步骤"></a>海明码求解步骤</h4><p>举例：信息位为1010</p>
<ol>
<li><p>确定海明码的位数，由上述 n 与 k 的关系，可知 n = 4,得k = 3，设信息位为<strong>D<sub>4</sub>D<sub>3</sub>D<sub>2</sub>D<sub>1</sub></strong>(1010)，共 4 位，校验位 P<sub>1</sub>P<sub>2</sub>P<sub>3</sub> 共 3 位，对应海明码为 H<sub>7</sub>H<sub>6</sub>H<sub>5</sub>H<sub>4</sub>H<sub>3</sub>H<sub>2</sub>H<sub>1</sub> 。</p>
</li>
<li><p>确定校验位的分布：校验位 P<sub>i</sub> 放在海明位号为2<sup>i-1</sup>的位置上，信息位按顺序放到其余位置。</p>
<table>
<thead>
<tr>
<th>H<sub>7</sub></th>
<th>H<sub>6</sub></th>
<th>H<sub>5</sub></th>
<th>H<sub>4</sub></th>
<th>H<sub>3</sub></th>
<th>H<sub>2</sub></th>
<th>H<sub>1</sub></th>
</tr>
</thead>
<tbody><tr>
<td>D<sub>4</sub></td>
<td>D<sub>3</sub></td>
<td>D<sub>2</sub></td>
<td>P<sub>3</sub></td>
<td>D<sub>1</sub></td>
<td>P<sub>2</sub></td>
<td>P<sub>1</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td><u>0</u></td>
<td>0</td>
<td><u>1</u></td>
<td><u>0</u></td>
</tr>
</tbody></table>
</li>
<li><p>分组以形成校验关系</p>
<p>每个数据位用多个校验位进行校验，且应满足条件：<strong>被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。</strong></p>
<p>所以D<sub>1</sub>应该由 P<sub>2 </sub>P<sub>1 </sub>校验，D<sub>2</sub>应该由 P<sub>3 </sub>P<sub>1 </sub>校验，D<sub>3</sub>应该由 P<sub>3 </sub>P<sub>2 </sub>校验，D<sub>4</sub>应该由 P<sub>3 </sub>P<sub>2 </sub>P<sub>1 </sub>校验</p>
<p>故分组如下：</p>
<ul>
<li>第 1 组：P<sub>1 </sub>D<sub>1</sub> D<sub>2</sub> D<sub>4</sub> （D<sub>1</sub> D<sub>2</sub> D<sub>4</sub> 都被 P<sub>1</sub> 所检验 ）</li>
<li>第 2 组：P<sub>2 </sub>D<sub>1</sub> D<sub>3</sub> D<sub>4</sub> （D<sub>1</sub> D<sub>3</sub> D<sub>4</sub> 都被 P<sub>2</sub> 所检验 ）</li>
<li>第 3 组：P<sub>3 </sub>D<sub>2</sub> D<sub>3</sub> D<sub>4</sub> （D<sub>2</sub> D<sub>3</sub> D<sub>4</sub> 都被 P<sub>3</sub> 所检验 ）</li>
</ul>
</li>
<li><p>求校验位的值：（可采用下图所示的方法）</p>
 <img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207161718268.png" style="zoom:80%;" /></li>
<li><p>纠错</p>
</li>
</ol>
<p>（1）接收到：1010010</p>
<table>
<thead>
<tr>
<th>H<sub>7</sub></th>
<th>H<sub>6</sub></th>
<th>H<sub>5</sub></th>
<th>H<sub>4</sub></th>
<th>H<sub>3</sub></th>
<th>H<sub>2</sub></th>
<th>H<sub>1</sub></th>
</tr>
</thead>
<tbody><tr>
<td>D<sub>4</sub></td>
<td>D<sub>3</sub></td>
<td>D<sub>2</sub></td>
<td>P<sub>3</sub></td>
<td>D<sub>1</sub></td>
<td>P<sub>2</sub></td>
<td>P<sub>1</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td><u>0</u></td>
<td>0</td>
<td><u>1</u></td>
<td><u>0</u></td>
</tr>
</tbody></table>
<p>校验方程：<br>$$<br>S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0<br>$$</p>
<p>$$<br>S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus 0 \oplus 1 = 0<br>$$</p>
<p>$$<br>S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus 0 \oplus 1 = 0<br>$$<br>数据无错误</p>
<p>（2）接收到1<u>1</u>10010（D<sub>3 </sub>发生了跳变）</p>
<p>校验方程：<br>$$<br>S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4 = 0 \oplus 0 \oplus 1 \oplus 1 = 0<br>$$</p>
<p>$$<br>S_2 = P_2 \oplus D_1 \oplus D_3 \oplus D_4 = 1 \oplus 0 \oplus \underline1 \oplus 1 = 1<br>$$</p>
<p>$$<br>S_3 = P_3 \oplus D_2 \oplus D_3 \oplus D_4 = 0 \oplus 1 \oplus \underline1 \oplus 1 = 1<br>$$</p>
<p>那么 我们由 S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 可以得到错误的位置为第6位(H<sub>6</sub>)，即D<sub>3 </sub>发生了错误</p>
<p><strong>Question: 为何可以通过S<sub>3</sub>S<sub>2</sub>S<sub>1</sub>得到错误的位置？为何不是S<sub>1</sub>S<sub>2</sub>S<sub>3</sub>？</strong></p>
<div class="note note-info">
            <p>Answer: 我们分别把 P<sub>3</sub>P<sub>2</sub>P<sub>1 </sub> 放到 421 的位置（把 P<sub>i</sub> 放在2<sup>i-1</sup>的位置），我们可以把它理解成一种权重，与海明位号二进制表示的各个权重是一一对应的！回顾一下上面求校验位值的过程，校验方程 S<sub>i</sub> 中包含的校验位即是 P<sub>i</sub> ，按从大到小的权重排列即是：S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> 。所以上述发生了错误对于各校验方程的值： S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 ，即指出错误的位置为第6位(H<sub>6</sub>)，即D<sub>3 </sub>发生了错误。</p>
          </div>

<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207161718268.png"  />

<h4 id="（补充）海明码的检错、纠错能力"><a href="#（补充）海明码的检错、纠错能力" class="headerlink" title="（补充）海明码的检错、纠错能力"></a>（补充）海明码的检错、纠错能力</h4><p>纠错能力 —— 1位</p>
<p>检错能力 —— 2位</p>
<ol>
<li><p>但是海明码<strong>无法区分是1位错还是2位错</strong>，还是上面的例子，S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 110 ，错误的位置一定为第6位？还可以是P<sub>3</sub>P<sub>2</sub>发生了错误对不对www</p>
</li>
<li><p>为了区分 1 位错和 2 位错，常添加“全校验位”对整体进行偶校验。</p>
<table>
<thead>
<tr>
<th>H<sub>8</sub></th>
<th>H<sub>7</sub></th>
<th>H<sub>6</sub></th>
<th>H<sub>5</sub></th>
<th>H<sub>4</sub></th>
<th>H<sub>3</sub></th>
<th>H<sub>2</sub></th>
<th>H<sub>1</sub></th>
</tr>
</thead>
<tbody><tr>
<td>P<sub>全</sub></td>
<td>D<sub>4</sub></td>
<td>D<sub>3</sub></td>
<td>D<sub>2</sub></td>
<td>P<sub>3</sub></td>
<td>D<sub>1</sub></td>
<td>P<sub>2</sub></td>
<td>P<sub>1</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td><u>0</u></td>
<td>0</td>
<td><u>1</u></td>
<td><u>0</u></td>
</tr>
</tbody></table>
</li>
</ol>
<p>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> = 000 且全体偶校验成功 → 无错误</p>
<p>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> ≠ 000 且全体偶校验失败 → 有1位错，纠正即可</p>
<p>S<sub>3</sub>S<sub>2</sub>S<sub>1</sub> ≠ 000 且全体偶校验成功 → 有2位错，需重传</p>
<h3 id="循环冗余校验码（CRC码）"><a href="#循环冗余校验码（CRC码）" class="headerlink" title="循环冗余校验码（CRC码）"></a>循环冗余校验码（CRC码）</h3><h4 id="循环冗余校验码的基本思想"><a href="#循环冗余校验码的基本思想" class="headerlink" title="循环冗余校验码的基本思想"></a>循环冗余校验码的基本思想</h4><ol>
<li><p>数据发送、接受方约定一个“除数” </p>
</li>
<li><p>K个信息位 + R个校验位 作为“被除数”，添加校验位后需保证除法的余数为0</p>
</li>
<li><p>收到数据后，进行除法检查余数是否为0，若余数非0说明出错，则进行重传或纠错</p>
</li>
</ol>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207174813942.png" style="zoom: 80%;" />

<p>例如：</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207174754144.png" style="zoom: 67%;" />



<h4 id="CRC码求解步骤"><a href="#CRC码求解步骤" class="headerlink" title="CRC码求解步骤"></a>CRC码求解步骤</h4><p>eg.1 设生成多项式为<em>G</em>(<em>x</em>)=<em>x</em><sup>3</sup>+<em>x</em><sup>2</sup>+1，信息码为101001，求对应的CRC码。</p>
<ol>
<li><p>确定K、R以及生成多项式对应的二进制码</p>
<p> K = 信息码的长度 = 6，R = 生成多项式最高次幂 = 3 –→ 校验码位数 N = K + R = 9</p>
<p> 生成多项式<em>G</em>(<em>x</em>)=1·<em>x</em><sup>3 </sup> + 1·<em>x</em><sup>2</sup>+ 0·x + 1，对应二进制码<strong>1101</strong></p>
</li>
<li><p>移位，信息码左移R位，低位补0</p>
</li>
<li><p>相除，对移位后的信息码，用生成多项式进行模2除法，产生余数（注意体会“模2除”、“模2减”）</p>
 <img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211207180100532.png"  />

<p> 对应的CRC码：101001 001</p>
</li>
<li><p>检错和纠错</p>
</li>
</ol>
<p>  发送：101001001，记为C<sub>9</sub>C<sub>8</sub>C<sub>7</sub>C<sub>6</sub>C<sub>5</sub>C<sub>4</sub>C<sub>3</sub>C<sub>2</sub>C<sub>1</sub><br>  接收：101001001</p>
<p>  用1101进行模2除 → 余数为000，代表没有出错</p>
<p>  接收：101001011<br>  用1101进行模2除 → 余数为010，代表C<sub>2</sub>出错</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Magpie来增加你的游戏体验！</title>
    <url>/2021/12/02/magpie/</url>
    <content><![CDATA[<h2 id="FSR算法和Anime4K算法"><a href="#FSR算法和Anime4K算法" class="headerlink" title="FSR算法和Anime4K算法"></a>FSR算法和Anime4K算法</h2><h3 id="FSR"><a href="#FSR" class="headerlink" title="FSR"></a>FSR</h3><p>​    AMD FidelityFX Super Resolution，简称FSR，中文名称是“AMD超级分辨率锐画技术”。就是使用超分辨率技术实现高分辨率，高品质游戏画面，并显著提高游戏运行效率的一套实现方法和程序库。它免费开源，跨平台，针对硬件进行了优化，集成到程序也非常简单（实际上只有两个文件），最神奇的是，运行它并不需要特殊的硬件，甚至如前几代的Intel CPU内集成的核显，都可以使用该技术。FSR算法正式开源后，FSR技术的源代码、开发文档、实例都已经放在了AMD GPUOpen网站上，开发者可以直接用于他们的游戏。AMD目前提供的实例支持DX12、Vulkan，但保证说编译着色器也兼容DX11。</p>
<p>​    AMD还表示，FSR技术不像NVIDIA DLSS那样依赖于运动向量(Motion Vector)或者历史缓冲区(History Buffer)，因此不需要专门的Tensor核心来加速，但同样也能使用时间数据，只是现阶段FSR的重心是简化开发、快速推向市场，技术上会逐步深入增强。来看看FSR的实际表现：</p>
<p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012549359.png"></p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012310018.png" style="zoom: 80%;" />


<h3 id="Anime4K"><a href="#Anime4K" class="headerlink" title="Anime4K"></a>Anime4K</h3><p>​    当你在看老番或是在推一部老物 gal &amp; avg ，是否在为其画质差而发愁？Anime4K（动漫图片超分辨率算法）即是一个实时、视频动画放大算法，不用等待处理视频动画的时间，在你观看的同时即可做到画质提升，在一周内，Anime4K在Github上收获了将近3千颗星，作者在6天前介绍了reddit上的项目，并成为每个人的热门话题，引起了极大的关注。引用一下作者原话：</p>
<div class="note note-info">
            <p>Anime4K is a set of open-source, high-quality real-time anime upscaling/denoising algorithms that can be implemented in any programming language.</p><p>The simplicity and speed of Anime4K allows the user to watch upscaled anime in real time, as we believe in preserving original content and promoting freedom of choice for all anime fans. Re-encoding anime into 4K should be avoided as it is non-reversible, potentially damages original content by introducing artifacts, takes up to O(n<sup>2</sup>) more disk space and more importantly, does so without any meaningful decrease in entropy (lost information is lost).</p>
          </div>

<p>​    附上开源项目原地址：<i class="fa fa-link" aria-hidden="true"></i> <a href="https://github.com/bloc97/Anime4K">https://github.com/bloc97/Anime4K</a></p>
<p>​    将其导入到支持的视频软件后，便可以享受1080P升级到近4K的画质了，来看看使用具体表现！</p>
<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012627278.png" style="zoom: 50%;" />

<img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204012707750.png" style="zoom: 50%;" />

<hr>
<h2 id="使用Magpie提高游戏体验"><a href="#使用Magpie提高游戏体验" class="headerlink" title="使用Magpie提高游戏体验"></a>使用Magpie提高游戏体验</h2><p>开源项目地址：<i class="fa fa-link" aria-hidden="true"></i> <a href="https://github.com/Blinue/Magpie/tree/v0.7.1">https://github.com/Blinue/Magpie/tree/v0.7.1</a></p>
<blockquote>
<p>Magpie 可以将任意窗口放大至全屏，支持多种高级缩放算法，包括 Lanczos、<a href="https://github.com/bloc97/Anime4K">Anime4K</a>、<a href="https://github.com/GPUOpen-Effects/FidelityFX-FSR">FSR</a>、<a href="https://github.com/igv/FSRCNN-TensorFlow">FSRCNNX</a>等。</p>
<p>主要用于游戏窗口的放大显示，适用于不支持全屏模式，或者内置的全屏模式会使画面模糊的情况。</p>
</blockquote>
<p><img src="http://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20211204013127026.png"></p>
<p>上面提到的两个算法，Magpie全部支持，不能全屏的老游戏都可以全屏，还可以使用Anime4K算法让其<del>全部变为4K画质？</del>（当然不可能全部提升到4K，但观感比原生画质好太多。当然游戏和动画的画质低，提升效果也就相对较差，720P以上的游戏提升效果会比较好！1080P提升后与4K观感相差无几，涂抹感很少。</p>
<p>当然，使用算法实时渲染提升画质，对显卡来说是有性能要求的，所以要想畅玩享受全屏清晰画质的 anime &amp; gal 的话，一个相对来说好点显卡是必须的。</p>
<p>对于提升游戏帧数来说，不同游戏的体验不同，实际使用Magpie支持的FSR算法体验不算很好，期待以后算法的改善。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>找到二叉树给定两结点的共同祖先</title>
    <url>/2021/12/26/common-ancestor-of-the-binary-tree/</url>
    <content><![CDATA[<h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><h3 id="如何得到一个给定结点的所有祖先？"><a href="#如何得到一个给定结点的所有祖先？" class="headerlink" title="如何得到一个给定结点的所有祖先？"></a>如何得到一个给定结点的所有祖先？</h3><!-- more -->我们很容易想到后序遍历，利用栈实现后序遍历时，遍历到某结点时，栈中所有元素即该结点祖先。

<p>那么找出给定结点的所有祖先的算法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//todo  输出x的所有祖先</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Anc_Print</span><span class="hljs-params">(BiTree T, TElemType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree p = T, r = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//r先用来标记右子树是否被访问过</span><br>    SqStack S; <span class="hljs-built_in">InitSqStack</span>(S); <span class="hljs-comment">//初始化栈</span><br>    <span class="hljs-keyword">while</span>(p || S.top != <span class="hljs-number">-1</span>)    <span class="hljs-comment">//进行后序遍历</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)    <span class="hljs-comment">//一直入栈直到树的左下</span><br>        &#123;<br>            <span class="hljs-built_in">SqPush</span>(S, p);<br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">//  转为右子树</span><br>        &#123;<br>            <span class="hljs-built_in">SqGetTop</span>(S, p);<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)    <span class="hljs-comment">// 右子树存在且没被访问过</span><br>                p = p-&gt;rchild;    <span class="hljs-comment">//转向</span><br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">//  右子树不存在或被访问过了</span><br>            &#123;<br>                <span class="hljs-built_in">SqPop</span>(S, p);<br>                <span class="hljs-keyword">if</span>(p-&gt;data == x)<br>                    <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//找到值为x的结点，退出循环</span><br>                r = p;<br>                p = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(S.top != <span class="hljs-number">-1</span>)    <span class="hljs-comment">//输出所有祖先</span><br>    &#123;<br>        <span class="hljs-built_in">SqPop</span>(S, p);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c  &quot;</span>,p-&gt;data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何找到两结点共同点祖先？"><a href="#如何找到两结点共同点祖先？" class="headerlink" title="如何找到两结点共同点祖先？"></a>如何找到两结点共同点祖先？</h3><p>由上面的过程，我们不难想到，后序遍历到某结点时，栈S中所有元素即该结点祖先。遍历到p或q时，将栈S中元素复制到一辅助栈S1里，再继续遍历到另一所求结点，那么从栈S栈顶开始逐个到辅助栈S1中去匹配，第一个匹配的结点即最近祖先。</p>
<h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><ol>
<li><p>首先我们希望输入想要找的结点的值，就能通过此值定向到该结点（树中所有结点data域均不同），从而去寻找共同祖先，那么首先我们需要指向data域等于我们input值的指针，可以通过如下代码实现：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//todo 找到指向x的指针</span><br><span class="hljs-function">BiTree <span class="hljs-title">Find_x</span><span class="hljs-params">(BiTree T, TElemType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;data == x)<br>        <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Find_x</span>(T-&gt;lchild, x))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find_x</span>(T-&gt;lchild, x);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">Find_x</span>(T-&gt;rchild, x);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>通过上述思想，将共同祖先保存到r：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Ancestor</span><span class="hljs-params">(BiTree T, BiTree p, BiTree q, BiTree &amp;r)</span>  <span class="hljs-comment">//最后将最近共同祖先保存到 r</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree temp = T, x = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//? temp为工作指针;先找到p,则x指向q,先找到q,则x指向p</span><br>    r = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//? r先用来标记右子树是否被访问过</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, tag = <span class="hljs-number">0</span>;    <span class="hljs-comment">//?  tag记录是否找到了p或q(此时栈S1中已复制完成)</span><br>    SqStack S; <span class="hljs-built_in">InitSqStack</span>(S);<br>    SqStack S1; <span class="hljs-built_in">InitSqStack</span>(S1);<br>    <span class="hljs-keyword">while</span>(temp || S.top != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(temp)    <span class="hljs-comment">//? 一直入栈直到树的左下</span><br>        &#123;<br>            <span class="hljs-built_in">SqPush</span>(S, temp);<br>            temp = temp-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">//?  转为右子树</span><br>        &#123;<br>            <span class="hljs-built_in">SqGetTop</span>(S, temp);<br>            <span class="hljs-keyword">if</span>(temp-&gt;rchild &amp;&amp; temp-&gt;rchild != r) <span class="hljs-comment">//? 右子树存在且没被访问过</span><br>                temp = temp-&gt;rchild;    <span class="hljs-comment">//转向</span><br>            <span class="hljs-keyword">else</span>    <span class="hljs-comment">//?  右子树不存在或被访问过了</span><br>            &#123;<br>                <span class="hljs-built_in">SqPop</span>(S, temp);        <span class="hljs-comment">//* 将栈顶结点出栈，让 temp指向它</span><br>                <span class="hljs-keyword">if</span>(!tag &amp;&amp; (temp == p || temp == q))    <span class="hljs-comment">//*  tag = 1时，说明已找到p或者q,所以此if下语句全程只会执行一次</span><br>                &#123;<br>                    x = temp==p ? q : p;<br>                    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt;= S.top; i++)<br>                        S1.data[i] = S.data[i];<br>                    S1.top = S.top;<br>                    tag = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp == x)<br>                    <span class="hljs-keyword">break</span>;<br>                r = temp;<br>                temp = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i0 = i;  <span class="hljs-comment">//i0存放S1的栈顶</span><br>    j = S.top;<br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)    <span class="hljs-comment">//栈S从栈顶开始，从辅助栈S1中逐个寻找相同元素</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; S.data[j] != S1.data[i])<br>            i--;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            i = i0;  <span class="hljs-comment">//i重新指向栈顶</span><br>            j--;  <span class="hljs-comment">//继续从栈S下一个元素开始逐个与S1匹配</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">//i&gt;=0说明匹配成功，退出循环</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)<br>        r = S1.data[i];<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">//如果i&lt;0，则寻找失败，无共同祖先</span><br>        r = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>返回指向r的指针（考虑到上面算法会出错的情况并完善）：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BiTree <span class="hljs-title">ComAnc_Node</span><span class="hljs-params">(BiTree T, TElemType p, TElemType q)</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree r, n1, n2;<br>    n1 = <span class="hljs-built_in">Find_x</span>(T, p);<br>    n2 = <span class="hljs-built_in">Find_x</span>(T, q);<br>    <span class="hljs-keyword">if</span>(!n1 || !n2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(p==T-&gt;data || q==T-&gt;data)<br>        <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-built_in">Ancestor</span>(T, n1, n2, r);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>试运行：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">int</span> i;<br>    BiTree T,Tnew,com_anc;<br>    TElemType e1;<br>    <span class="hljs-built_in">InitBiTree</span>(&amp;T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化二叉树后,树空否？\n%d(1:是 0:否) 树的深度=%d\n&quot;</span>, <span class="hljs-built_in">BiTreeEmpty</span>(T), <span class="hljs-built_in">BiTreeDepth</span>(T));<br>    <span class="hljs-built_in">StrAssign</span>(str, <span class="hljs-string">&quot;ABDH#K###E##CFI###G#J##&quot;</span>);<br>    <span class="hljs-comment">//按前序输入</span><br>    <span class="hljs-built_in">CreateBiTree</span>(&amp;T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;构造二叉树后,树空否？\n%d(1:是 0:否) 树的深度=%d\n&quot;</span>, <span class="hljs-built_in">BiTreeEmpty</span>(T), <span class="hljs-built_in">BiTreeDepth</span>(T));<br>    e1 = <span class="hljs-built_in">Root</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;二叉树的根为: %c\n&quot;</span>, e1);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;树的高度:%d\n&quot;</span>, <span class="hljs-built_in">BtDepth_2</span>(T));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n前序递归遍历二叉树T:&quot;</span>);<br>    <span class="hljs-built_in">PreOrderTraverse</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n中序递归遍历二叉树T:&quot;</span>);<br>    <span class="hljs-built_in">InOrderTraverse</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n后序递归遍历二叉树T:&quot;</span>);<br>    <span class="hljs-built_in">PostOrderTraverse</span>(T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n    层次遍历二叉树T:&quot;</span>);<br>    <span class="hljs-built_in">LevelOrderTraverse</span>(T);<br>    com_anc = <span class="hljs-built_in">ComAnc_Node</span>(T, <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(com_anc)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最近祖先为：%c\n&quot;</span>, com_anc-&gt;data);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入不合法或无共同祖先\n&quot;</span>);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 运行结果：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">前序递归遍历二叉树T: ABDHKECFIGJ<br>中序递归遍历二叉树T: HKDBEAIFCGJ<br>后续递归遍历二叉树T: KHDEBIFJGCA<br>最近祖先为: B<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>2022新年快乐！</title>
    <url>/2022/02/01/newyear2022/</url>
    <content><![CDATA[<p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201002705612.png"></p>
<p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201002738797.png"></p>
<p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201002759448.png"></p>
<p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201002831626.png"></p>
<p><img src="https://kusanagi.oss-cn-beijing.aliyuncs.com/img/image-20220201103327465.png"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
