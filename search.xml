<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Magpie</title>
    <url>/2021/12/02/magpie/</url>
    <content><![CDATA[<p>test</p>
]]></content>
      <categories>
        <category>resources</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树四种遍历的非递归方式</title>
    <url>/2021/12/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前序、中序和后续遍历"><a href="#前序、中序和后续遍历" class="headerlink" title="前序、中序和后续遍历"></a>前序、中序和后续遍历</h2><span id="more"></span>

<ol>
<li>需用到栈：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BiTree data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    S-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S, BiTree e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == e)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">    LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(StackNode));   <span class="comment">//s指向新栈结点的指针</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = S-&gt;top; <span class="comment">/* 把当前的栈顶元素赋值给新结点的直接后继 */</span></span><br><span class="line">    S-&gt;top = s;       <span class="comment">/* 将新的结点s赋值给栈顶指针 */</span></span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S, BiTree *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    <span class="keyword">if</span> ((*S).count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">	*e = S-&gt;top-&gt;data;</span><br><span class="line">    p = S-&gt;top;            <span class="comment">/* 将栈顶结点赋值给p */</span></span><br><span class="line">    S-&gt;top = S-&gt;top-&gt;next; <span class="comment">/* 使得栈顶指针下移一位，指向后一结点 */</span></span><br><span class="line">    <span class="built_in">free</span>(p);               <span class="comment">/* 释放结点p */</span></span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(LinkStack S, BiTree &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p = S.top-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>前序遍历实现：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*  初始条件：二叉树T存在</span></span><br><span class="line"><span class="comment">//todo  操作结果：前序非递归遍历T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse_2</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkStack S;</span><br><span class="line">	<span class="built_in">InitStack</span>(&amp;S);</span><br><span class="line">	BiTree p = T;</span><br><span class="line">	<span class="keyword">while</span>(p || S.count != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p)		<span class="comment">//?  左子树不为空</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);</span><br><span class="line">			<span class="built_in">Push</span>(&amp;S, p);	<span class="comment">//?  栈存放各子树的右子树</span></span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Pop</span>(&amp;S, &amp;p);</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//?  当左子树为空，且栈空，退出循环</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>中序遍历实现：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*  初始条件：二叉树T存在</span></span><br><span class="line"><span class="comment">//todo  操作结果：中序非递归遍历T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_2</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkStack S;</span><br><span class="line">	<span class="built_in">InitStack</span>(&amp;S);</span><br><span class="line">	BiTree p = T;</span><br><span class="line">	<span class="keyword">while</span>(p || S.count != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p)		<span class="comment">//?  左子树不为空</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Push</span>(&amp;S, p);	<span class="comment">//?  栈存放各子树的根结点</span></span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//?  左子树空，弹出栈顶元素并输出，转为右子树继续循环</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Pop</span>(&amp;S, &amp;p);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//?  当左子树为空，且栈空，退出循环</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>后序遍历实现：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*  初始条件：二叉树T存在</span></span><br><span class="line"><span class="comment">//todo  操作结果：后序非递归遍历T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse_2</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree p = T, r = <span class="literal">NULL</span>;</span><br><span class="line">	LinkStack S;</span><br><span class="line">	<span class="built_in">InitStack</span>(&amp;S);</span><br><span class="line">	<span class="keyword">while</span>(p || S.count != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p)		<span class="comment">//todo  走到最左边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Push</span>(&amp;S, p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">GetTop</span>(S, p);</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)		<span class="comment">//*  若右子树存在, 且未被访问过</span></span><br><span class="line">				p = p-&gt;rchild;		<span class="comment">//todo 转向右边</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Pop</span>(&amp;S, &amp;p);</span><br><span class="line">				<span class="built_in">visit</span>(p-&gt;data);</span><br><span class="line">				r = p;		<span class="comment">//*  记录最近访问过的结点</span></span><br><span class="line">				p = <span class="literal">NULL</span>;	<span class="comment">//?  将p置空</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//else</span></span><br><span class="line">	&#125;<span class="comment">//while</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、层次遍历"><a href="#二、层次遍历" class="headerlink" title="二、层次遍历"></a>二、层次遍历</h2><ol>
<li><p>需用到队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BiTree *data;</span><br><span class="line">    <span class="keyword">int</span> front; <span class="comment">/* 头指针 */</span></span><br><span class="line">    <span class="keyword">int</span> rear;  <span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.data = (BiTree *)<span class="built_in">malloc</span>((MAXSIZE+<span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(BiTree));</span><br><span class="line">    <span class="keyword">if</span>(!Q.data)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front = <span class="number">0</span>;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, BiTree e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) <span class="comment">/* 队列满的判断 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.data[Q.rear] = e;              <span class="comment">/* 将元素e赋值给队尾 */</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE; <span class="comment">/* rear指针向后移一位置， */</span></span><br><span class="line">                                       <span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, BiTree &amp;e)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">/* 队列空的判断 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.data[Q.front];              <span class="comment">/* 将队头元素赋值给e */</span></span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE; <span class="comment">/* front指针向后移一位置， */</span></span><br><span class="line">                                         <span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>层次遍历实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//todo  操作结果：层次遍历T </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree p;</span><br><span class="line">	SqQueue qu;	<span class="comment">//使用队列来层次遍历二叉树</span></span><br><span class="line">	<span class="built_in">InitQueue</span>(qu);</span><br><span class="line">	<span class="built_in">EnQueue</span>(qu, T);</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(qu))		<span class="comment">//队列非空/*  */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeQueue</span>(qu, p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild)</span><br><span class="line">			<span class="built_in">EnQueue</span>(qu, p-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild)</span><br><span class="line">			<span class="built_in">EnQueue</span>(qu, p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
